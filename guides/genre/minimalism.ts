export const MINIMALISM_THEORY_GUIDE = `
# ミニマリズム音楽完全技術仕様書：生成AI実装のための統合マニュアル
## スティーブ・ライヒ＆フィリップ・グラス技法の完全解析

---

## 【目次構造】

### 第I部：理論的基礎
1. ミニマリズム音楽の哲学と定義
2. プロセス音楽の数学的基盤
3. ライヒとグラスの技法比較論

### 第II部：スティーブ・ライヒの技法
4. フェイジング（位相ずれ）の完全仕様
5. 加算的プロセスと減算的プロセス
6. 結果パターンの生成理論
7. ライヒ代表作品の完全解析

### 第III部：フィリップ・グラスの技法
8. 加算的構造（グラス版）の理論
9. 和声循環システム
10. 拍子変化とポリリズム
11. グラス代表作品の完全解析

### 第IV部：実装技術
12. 音高システムと音階理論
13. リズム構造の数学的記述
14. 楽器編成と音色設計
15. MIDI生成アルゴリズム

### 第V部：生成AI実装ガイド
16. 完全実装コードライブラリ
17. 検証基準とチェックリスト
18. トラブルシューティングガイド

---

# 第I部：理論的基礎

## 1. ミニマリズム音楽の哲学と定義

### 1.1 ミニマリズムの核心概念

**定義**：最小限の音楽素材を用いて、段階的変化のプロセスを聴取可能にする音楽様式

**5つの原理**：

\`\`\`
【原理1：知覚可能なプロセス】
- プロセス自体が音楽内容である
- 変化は聴取者が追跡できる速度で進行
- 「何が起こっているか」が常に明確

【原理2：素材の制限】
- 5~12音の音高集合
- 8~16拍の基本パターン
- 単一または少数の楽器群

【原理3：反復の美学】
- 同一パターンの執拗な反復
- 反復回数：8~48回/変化段階
- 反復により「時間」が物質化

【原理4：段階的変化】
- 突然の転換を排除
- 変化単位：1音符、1拍、1位相単位
- 変化速度：7~60秒/段階

【原理5：調性の再定義】
- 機能和声の否定
- 調性感覚の持続（無調ではない）
- モーダルまたはペンタトニック中心
\`\`\`

### 1.2 歴史的位置づけ

**時代的文脈**：
\`\`\`
1960年代初頭：前衛音楽への反動
├─ セリー主義（十二音技法）からの離脱
├─ ケージ的偶然性からの離脱
└─ ヨーロッパ前衛主義への対抗

主要人物：
├─ La Monte Young (1935-) : 持続音美学の創始
├─ Terry Riley (1935-) : 《In C》(1964) - 開放形式
├─ Steve Reich (1936-) : フェイジング技法
└─ Philip Glass (1937-) : 加算的構造

影響源：
├─ インド古典音楽（タラ、ラーガ）
├─ ガーナEwe族の打楽器音楽
├─ バリのガムラン音楽
└─ 中世・バロック音楽（オスティナート、カノン）
\`\`\`

### 1.3 ライヒ vs グラス：根本的相違

\`\`\`
┌─────────────────┬──────────────────────┬──────────────────────┐
│ 比較軸          │ スティーブ・ライヒ    │ フィリップ・グラス    │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 哲学的起源      │ バロック音楽          │ インド古典音楽        │
│                │ (カノン、フーガ)      │ (タラ、ラーガ)        │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 核心技法        │ フェイジング          │ 加算的プロセス        │
│                │ (位相ずれ)            │ (音符追加・削除)      │
├─────────────────┼──────────────────────┼──────────────────────┤
│ プロセスの性質  │ 客観的・自動的        │ 主観的・作曲的        │
│                │ (機械的決定論)        │ (即興的要素)          │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 時間感覚        │ 線形的                │ 循環的                │
│                │ (明確な始点・終点)    │ (無限ループ感)        │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 和声システム    │ 静的和声              │ 動的和声進行          │
│                │ (単一調中心)          │ (3~5和音サイクル)     │
├─────────────────┼──────────────────────┼──────────────────────┤
│ リズム構造      │ 固定拍子              │ 可変拍子              │
│                │ (4/4, 12/8)           │ (5/8, 7/8, 11/8)      │
├─────────────────┼──────────────────────┼──────────────────────┤
│ パターン対称性  │ 高 (70~90%)           │ 低 (20~40%)           │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 楽器選択        │ アコースティック      │ 電子・増幅楽器        │
│                │ (マリンバ、ピアノ)    │ (オルガン、シンセ)    │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 形式時間        │ 固定 (15~20分)        │ 可変 (5分~5時間)      │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 聴取体験        │ 知覚実験              │ 瞑想的・催眠的        │
│                │ (科学的興味)          │ (トランス状態)        │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 影響力の範囲    │ 現代音楽・学術界      │ ポップス・映画音楽    │
└─────────────────┴──────────────────────┴──────────────────────┘

【実装判定基準】
- フェイジングが中心 → ライヒ技法を選択
- 和声進行がある → グラス技法を選択
- 打楽器中心 → ライヒ技法を選択
- 電子音色中心 → グラス技法を選択
\`\`\`

---

## 2. プロセス音楽の数学的基盤

### 2.1 プロセスの形式的定義

**プロセス音楽とは**：
音楽的素材に対する規則的変換の時系列展開

**数学的記述**：
\`\`\`
Music = Process(Material, Time)

where:
  Material = {Pitches, Rhythms, Timbres}
  Process = Transform: State(t) → State(t+1)
  Time = Discrete or Continuous parameter
\`\`\`

### 2.2 三大プロセス・タイプの完全定義

#### A. フェイジング・プロセス（位相ずれ）

**定義**：
複数の同一パターンが微妙に異なる速度で演奏され、位相関係が連続的に変化するプロセス

**数学的モデル**：
\`\`\`
Pattern P(t): 長さLの周期関数
Voice1(t) = P(t mod L)
Voice2(t) = P((t + φ(t)) mod L)

位相差 φ(t) の時間発展:
  φ(t) = ∫₀ᵗ (v₂ - v₁) dt'
  
  v₁ = 基準速度 (BPM)
  v₂ = v₁ × (1 + δ)
  δ = 速度差比率 = 0.01~0.03 (1~3%)

位相ずれ速度:
  dφ/dt = v₂ - v₁ = v₁ × δ

完全な位相サイクル時間:
  T_cycle = L / (v₁ × δ) [秒]
  
例：Lライヒ《Piano Phase》
  L = 12音
  v₁ = 432 notes/分 = 7.2 notes/秒
  δ = 0.015 (1.5%)
  T_cycle = 12 / (7.2 × 0.015) = 111秒 ≈ 1分51秒
\`\`\`

**段階的フェイジング**（《Clapping Music》型）：
\`\`\`
離散的位相ジャンプ:
  φ(n) = n × Δφ
  Δφ = 1音符 (パターン長の1/L)
  
各位相位置での反復回数: R = 8~24回

総演奏時間:
  T_total = L × R × (60/BPM) [秒]
\`\`\`

#### B. 加算的プロセス

**ライヒ版（《Drumming》型）**：
\`\`\`
定義: 休符が段階的に音符に置換される

初期状態: Pattern₀ = [n₁, R, R, n₂, R, n₃, ...]
  where n = note, R = rest

変換規則:
  Stage_k = Stage_{k-1} + {音符k個追加}
  
置換順序: 構造的決定論
  1. 弱拍位置の休符から
  2. 強拍周辺の休符
  3. 重要なシンコペーション位置

反復回数: 各段階で12~24回

数式表現:
  Pattern_k(i) = {
    Note(pitch_k(i))  if i ∈ FillSet_k
    Rest              if i ∉ FillSet_k
  }
  
  FillSet_k ⊂ FillSet_{k+1} (単調増加)
\`\`\`

**グラス版（《Einstein on the Beach》型）**：
\`\`\`
定義: パターン長そのものが変化

初期: Pattern₀ = [n₁, n₂, n₃, n₄, n₅]
段階1: Pattern₁ = [n₁, n₂, n₃, n₄, n₅, n₆, n₇]
段階2: Pattern₂ = [n₁, n₂, n₃, n₄, n₅, n₆, n₇, n₈, n₉]
...

変換規則:
  Length(Pattern_k) = Length(Pattern_{k-1}) + Δn
  Δn = 1~4音 (典型的には2音)

対称性: 低 (20~40%)
予測可能性: 中 (作曲的決定)
\`\`\`

#### C. パルス抽出プロセス（結果パターン）

**定義**：
複数の反復パターンの重なりから生じる心理音響的副産物

**生成条件**：
\`\`\`
1. 2つ以上のパターンが位相ずれ状態
2. 音高が部分的に重複
3. 聴取者の注意がパターン内の特定音高連鎖に焦点化

数学的記述:
  ResultantPattern(θ) = {
    音 p | ∃i,j: Voice1[i] = Voice2[(j+θ) mod L] = p
           AND |Time(Voice1[i]) - Time(Voice2[(j+θ) mod L])| < ε
  }
  
  θ = 位相差 (0~L-1)
  ε = 時間的近接性閾値 (典型的には1/32音符以内)
\`\`\`

**具体例：《Piano Phase》位相4における結果パターン**：
\`\`\`
Piano 1: E4-F♯4-B4-C♯5-D5-F♯4-E4-C♯5-B4-F♯4-D5-C♯5
Piano 2:     D5-F♯4-E4-C♯5-B4-F♯4-D5-C♯5-E4-F♯4-B4-C♯5

時間的重複（ε=0.05秒以内）:
  位置2: F♯4 (両方)
  位置6: F♯4 (両方)
  位置7: E4 (両方)
  位置8,12: C♯5 (両方)

知覚的旋律: F♯-E-C♯の下降フレーズが浮上
\`\`\`

### 2.3 プロセスの階層性理論

**3階層モデル**：
\`\`\`
┌──────────────────────────────────────────────────────┐
│ レベル3: マクロ構造 (Form)                            │
│ ・全体形式: 15~90分                                   │
│ ・セクション数: 3~14                                  │
│ ・アーチ形式頻度: 高                                  │
│ ・プロセス連鎖: 単一 or 複数                          │
│                                                      │
│  例：《Music for 18 Musicians》                       │
│      14セクション、アーチ型配置                       │
└──────────────────────────────────────────────────────┘
           ↑ 組織化
┌──────────────────────────────────────────────────────┐
│ レベル2: メソ構造 (Section)                           │
│ ・セクション長: 2~6分                                 │
│ ・位相位置: 12~24サイクル安定                         │
│ ・プロセス遷移: 7~30秒                                │
│ ・和声単位: 1~5和音                                   │
│                                                      │
│  例：《Piano Phase》セクション1                       │
│      12音パターン、各位相12回反復                     │
└──────────────────────────────────────────────────────┘
           ↑ 組織化
┌──────────────────────────────────────────────────────┐
│ レベル1: マイクロ構造 (Pattern)                       │
│ ・基本単位: 8~16拍                                    │
│ ・音符密度: 16分音符連続                              │
│ ・音高範囲: 1~1.5オクターブ                           │
│ ・対称性: ライヒ70~90%, グラス20~40%                  │
│                                                      │
│  例：《Clapping Music》基本パターン                   │
│      X X X - X X - X - X X - (12拍)                  │
└──────────────────────────────────────────────────────┘
\`\`\`

---

# 第II部：スティーブ・ライヒの技法

## 4. フェイジング（位相ずれ）の完全仕様

### 4.1 《Piano Phase》（1967）の完全解析

#### 基本パラメータ

**パターン仕様**：
\`\`\`
長さ: 12音 (16分音符)
音高配列: E4-F♯4-B4-C♯5-D5-F♯4-E4-C♯5-B4-F♯4-D5-C♯5
MIDI値: [64, 66, 71, 73, 74, 66, 64, 73, 71, 66, 74, 73]

音高集合分析:
  基本: {E, F♯, B, C♯, D}
  音階: Bメジャー・ペンタトニック + C♯
  調中心: Bメジャー (暗示的)
  
音程構造統計:
  短2度: 1回 (E→F♯の逆行)
  長2度: 5回 (E-F♯, C♯-D等)
  短3度: 2回 (B-D)
  完全4度: 2回 (E-B, F♯-B)
  完全5度: 2回 (B-E逆行)
  長6度: 1回 (D-B)
  
パターン対称性: 約65% (部分的鏡映)
  [E-F♯-B-C♯-D-F♯] ←→ [E-C♯-B-F♯-D-C♯]
  前半と後半で音高集合がほぼ同じ
\`\`\`

#### テンポと位相パラメータ

\`\`\`
基準テンポ: ♩. = 72 BPM
  → ♩ = 108 BPM (4分音符換算)
  → 16分音符 = 432 notes/分 = 7.2 notes/秒

位相ずれメカニズム:
  Piano 1: 108.00 BPM (固定・基準)
  Piano 2: 109.62 BPM (位相中・1.5%速)
  
  速度差: Δv = 1.62 BPM
         = 0.027 notes/秒

16分音符1個分ずれる時間:
  Δt = (1音符の時間長) / (速度差比率)
     = (1/7.2秒) / 0.015
     = 0.1389秒 / 0.015
     ≈ 9.26秒

完全な位相サイクル (12音):
  T = 12 × 9.26秒
    = 111.12秒
    ≈ 1分51秒

ユニゾン→同期外れ→逆位相→同期外れ→ユニゾン回帰
\`\`\`

#### 3セクション構造の詳細

**【セクション1】完全12音パターン（約6分）**
\`\`\`
パターン: 全12音
位相回転数: 12回 (完全サイクル)
各位相での反復: 12~24回
演奏時間: 約6分

位相0 (ユニゾン):
  Piano1: E-F♯-B-C♯-D-F♯-E-C♯-B-F♯-D-C♯
  Piano2: E-F♯-B-C♯-D-F♯-E-C♯-B-F♯-D-C♯
  → 完全同期、単一音列として知覚

位相6 (逆位相):
  Piano1: E-F♯-B-C♯-D-F♯-E-C♯-B-F♯-D-C♯
  Piano2:       E-C♯-B-F♯-D-C♯-E-F♯-B-C♯-D-F♯
  → 最大複雑性、2つの独立ラインが明確

位相12 (ユニゾン回帰):
  完全同期に戻る
\`\`\`

**【セクション2】8音パターン（約5分）**
\`\`\`
パターン縮小: 12音 → 8音
使用音高: E4-F♯4-B4-C♯5-D5-F♯4-E4-C♯5
省略音: B4-F♯4-D5-C♯5 (後半4音)

位相回転数: 8回
各位相での反復: 10~20回
演奏時間: 約5分

位相サイクル時間短縮:
  T = 8 × 9.26秒 ≈ 74秒 (約1分14秒)
  → 変化速度が速くなる
\`\`\`

**【セクション3】4音パターン（約4分）**
\`\`\`
パターン最小化: 8音 → 4音
使用音高: B4-C♯5-D5-F♯4
省略音: E4系列を削除

位相回転数: 4回
各位相での反復: 16~32回
演奏時間: 約4分

位相サイクル時間最短:
  T = 4 × 9.26秒 ≈ 37秒
  → 最速の変化、クライマックス的効果
\`\`\`

**総演奏時間**: 15~20分 (演奏者の裁量により変動)

#### 結果パターンの体系的分析

**位相ごとの結果パターン抽出**：
\`\`\`
位相θにおける音響学的重複:
  Overlap(θ) = {p | Piano1[i]=p AND Piano2[(i+θ) mod 12]=p 
                    AND |Time_diff| < threshold}

位相1 (1音ずれ):
  Piano1: E-F♯-B-C♯-D-F♯-E-C♯-B-F♯-D-C♯
  Piano2:  F♯-B-C♯-D-F♯-E-C♯-B-F♯-D-C♯-E
  重複音: F♯(2箇所), C♯(2箇所), E(1箇所)
  結果旋律: F♯-C♯-E の断片的下降

位相2 (2音ずれ):
  Piano1: E-F♯-B-C♯-D-F♯-E-C♯-B-F♯-D-C♯
  Piano2:   B-C♯-D-F♯-E-C♯-B-F♯-D-C♯-E-F♯
  重複音: B(2), C♯(2), D(2), F♯(2)
  結果旋律: B-C♯-D-F♯ の上昇アルペジオ

位相3 (3音ずれ):
  Piano1: E-F♯-B-C♯-D-F♯-E-C♯-B-F♯-D-C♯
  Piano2:    C♯-D-F♯-E-C♯-B-F♯-D-C♯-E-F♯-B
  重複音: C♯(3), D(2), F♯(3), B(1)
  結果旋律: C♯-F♯-D の跳躍パターン

[位相4~11も同様に分析可能]

知覚的ピーク: 位相2, 6, 10
  → 音高重複が最も規則的で旋律的
\`\`\`

### 4.2 《Clapping Music》（1972）の段階的フェイジング

#### 完全仕様

**基本パターン**：
\`\`\`
表記: X X X - X X - X - X X -
  (Xは拍手、-は休符)

2進表記: 1 1 1 0 1 1 0 1 0 1 1 0
  (1=拍手, 0=休符)

パターン長: 12拍 (8分音符単位)
テンポ: ♪ = 158 BPM
1拍の長さ: 60/158 = 0.380秒

総演奏時間: 約5分
\`\`\`

#### 段階的フェイジングの仕組み

\`\`\`
メカニズム: 漸進的フェイジングではなく離散的ジャンプ

規則:
  1. Clapper 1は常に同じパターンを演奏
  2. Clapper 2は各位相位置で12回反復後、1音分右回転
  3. 12位相すべてを経て元の位置に回帰

反復回数: 各位相で12回 (約27秒/位相)
位相遷移: 瞬時 (遅延なし)
\`\`\`

**完全位相テーブル**：
\`\`\`
位相 | Clapper 1        | Clapper 2        | 衝突数 | 複雑性
-----|------------------|------------------|--------|--------
0    | 111011010110     | 111011010110     |   8    | 最小 (ユニゾン)
1    | 111011010110     | 110110101101     |   3    | 中
2    | 111011010110     | 101101011011     |   5    | 中
3    | 111011010110     | 011010110111     |   4    | 中
4    | 111011010110     | 110101101110     |   3    | 中
5    | 111011010110     | 101011011101     |   5    | 中
6    | 111011010110     | 010110111010     |   0    | 最大 (完全相補)
7    | 111011010110     | 101101110101     |   5    | 中
8    | 111011010110     | 011011101011     |   4    | 中
9    | 111011010110     | 110111010110     |   3    | 中
10   | 111011010110     | 101110101101     |   5    | 中
11   | 111011010110     | 011101011011     |   4    | 中
12   | 111011010110     | 111011010110     |   8    | 最小 (回帰)

衝突数の定義: 両クラッパーが同時に音を出す拍数

位相6が最も複雑:
  → Clapper 1が休符の位置でClapper 2が音を出す
  → Clapper 1が音の位置でClapper 2が休符
  → 完全に相補的なリズム
\`\`\`

#### 知覚的複雑性の数学的分析

\`\`\`
衝突関数:
  Collision(θ) = Σ[i=0 to 11] (P1[i] AND P2[(i+θ) mod 12])

複雑性関数:
  Complexity(θ) = 1 - (Collision(θ) / Total_Notes)
  Total_Notes = 8 (パターン内の音数)

位相別複雑性:
  θ=0:  Complexity = 0.00 (最も単純)
  θ=1:  Complexity = 0.625
  θ=2:  Complexity = 0.375
  θ=3:  Complexity = 0.50
  θ=4:  Complexity = 0.625
  θ=5:  Complexity = 0.375
  θ=6:  Complexity = 1.00 (最も複雑)
  θ=7:  Complexity = 0.375
  θ=8:  Complexity = 0.50
  θ=9:  Complexity = 0.625
  θ=10: Complexity = 0.375
  θ=11: Complexity = 0.50

複雑性グラフ: M字型の曲線
  ピーク: 位相6
  谷: 位相0, 12 (ユニゾン)
\`\`\`

### 4.3 《Drumming》（1970-71）の複合プロセス

#### 全体構造と時間配分

\`\`\`
総演奏時間: 55~75分 (演奏により大きく変動)
4部構成: 各パート独立したプロセス

【Part I: Tuned Bongos】(約25分)
  楽器: チューニングされたボンゴ4ペア (8台)
  音高: D4, F4, A4, C5 (短3度積層)
  基本パターン: 12拍サイクル
  プロセス: 漸進的置換 (Rest → Note)
  
【Part II: Marimba】(約26分)
  楽器: マリンバ3台 + 女声2 + ピッコロ
  音高: D3, F3, A3, C4 (Part Iのオクターブ下)
  プロセス: Part Iパターンの変奏 + 声楽的結果パターン
  
【Part III: Glockenspiel】(約16分)
  楽器: グロッケンシュピール3台 + ピッコロ + 口笛
  音高: D5, F5, A5, C6 (Part Iのオクターブ上)
  プロセス: ティンブル変化 + 高音域拡張
  
【Part IV: 統合】(約19分)
  全楽器統合
  3つのティンブル領域の同時展開
  クライマックス: 全要素の収束
\`\`\`

#### Ewe族ベルパターンの詳細

\`\`\`
起源: ガーナEwe族の伝統的打楽器パターン (Gankogui bell pattern)

標準表記 (8分音符単位):
  拍:  1  &  2  &  3  &  4  &  5  &  6  &  7  &  8  &  9  &  10 &  11 &  12 &
  音:  X     X     X     X  X     X  X  X     X  X  X      X   X

音価グループ:
  3-3-2-2-2 (8分音符カウント)
  = [0, 3, 6, 9, 11, 14, 16, 18, 21, 23, 25, 28, 30]

リズム的特徴:
  - 非対称的 (前半重く、後半密)
  - アフリカ的ヘミオラ感覚
  - 12拍サイクルだが4拍子的ではない
  
MIDI実装 (16分音符=1単位、4/4拍子):
  Onset_times = [0, 3, 6, 9, 11, 14, 16, 18, 21, 23, 25, 28, 30]
  Duration = 2 (16分音符2個分 = 8分音符)
  
ヴェロシティ:
  Strong beats (1, 4, 7, 10): 100
  Weak beats: 85
\`\`\`

#### 漸進的置換プロセスの数学的記述

\`\`\`
初期状態: 基本12拍パターンが完全確立
  Pattern₀ = [n₁, n₂, n₃, ..., n₁₃]
  (13個の音符位置)

中間状態: 休符位置に新音符が徐々に追加
  Pattern_k = Pattern_{k-1} ∪ {新規音符k個}

最終状態: すべての休符位置が音符化
  Pattern_final = 完全充填パターン

置換関数:
  S(t, pos) = {
    Note(pitch(pos))  if t ≥ t_transition(pos)
    Rest              if t < t_transition(pos)
  }
  
  where:
    t = 現在の反復サイクル番号
    pos = パターン内位置 (0~31, 32分音符単位)
    t_transition(pos) = 位置posで置換が発生するサイクル番号

置換順序の決定規則:
  1. 弱拍・裏拍の休符から優先
  2. シンコペーション効果が大きい位置
  3. 最後に強拍に隣接する位置
  
  → 音楽的緊張が段階的に増大
\`\`\`

#### 女声の結果パターン実装

\`\`\`
女声の役割:
  マリンバの3パートから浮かび上がる旋律を歌唱
  (演奏されていない「幽霊の旋律」を実体化)

抽出アルゴリズム:
  Step 1: 3マリンバの位相関係を分析
  Step 2: 同時または近接 (±1/32音符) して鳴る音高を特定
  Step 3: これらを時間順に配列
  Step 4: 跳躍を最小化して旋律的に連結
  Step 5: リズミックに整形 (器楽パルスに同期)

音節使用:
  ソルフェージュ: Do, Re, Mi, Fa, Sol
  または
  ニュートラル母音: Ah, Oh, Oo

音域: C4~C6 (ソプラノ)
ダイナミクス: mp~mf (器楽に埋没しない程度)
ヴィブラート: なし (純粋性維持)

実装例（Part II中盤）:
  Marimba 1: D-F-A-D-F-A-C-A...
  Marimba 2:   F-A-D-F-A-C-A-D...
  Marimba 3:     A-D-F-A-C-A-D-F...
  
  結果旋律抽出:
    時刻0.0: D (M1のみ)
    時刻0.3: F (M1, M2同時) ★
    時刻0.6: A (M1, M2, M3同時) ★★
    時刻0.9: D (M2, M3同時) ★
    ...
  
  女声が歌唱: F-A-D-A-... (★マークの音)
  音節: Sol-Do-Re-Do
\`\`\`

---

## 5. 加算的プロセスと減算的プロセス

### 5.1 加算的プロセス（ライヒ版）の理論

**定義**：
休符が段階的に音符に置換され、音楽的密度が増大するプロセス

**《Drumming》における実装**：
\`\`\`
【Stage 0: 基本パターン】
  拍:  1  2  3  4  5  6  7  8  9  10 11 12
  音:  X  -  X  -  X  -  X  X  -  X  X  -
  
  音符数: 8個
  密度: 67% (8/12)

【Stage 1: 第1次置換】
  拍:  1  2  3  4  5  6  7  8  9  10 11 12
  音:  X  X  X  -  X  -  X  X  -  X  X  -
  
  追加: 拍2に音符
  音符数: 9個
  密度: 75%

【Stage 2: 第2次置換】
  拍:  1  2  3  4  5  6  7  8  9  10 11 12
  音:  X  X  X  -  X  X  X  X  -  X  X  -
  
  追加: 拍6に音符
  音符数: 10個
  密度: 83%

【Stage 3: 第3次置換】
  拍:  1  2  3  4  5  6  7  8  9  10 11 12
  音:  X  X  X  X  X  X  X  X  -  X  X  -
  
  追加: 拍4に音符
  音符数: 11個
  密度: 92%

【Stage 4: 完全充填】
  拍:  1  2  3  4  5  6  7  8  9  10 11 12
  音:  X  X  X  X  X  X  X  X  X  X  X  X
  
  追加: 拍9, 12に音符
  音符数: 12個
  密度: 100%

置換順序の音楽的意図:
  1. 弱拍→強拍 (拍2, 6が先)
  2. シンコペーション保持 (拍4は遅れる)
  3. クライマックスで完全充填
\`\`\`

### 5.2 減算的プロセス（理論的逆操作）

**定義**：
充填されたパターンから音符が段階的に除去され、音楽的密度が減少するプロセス

**実装例（《Drumming》逆操作）**：
\`\`\`
【Stage 0: 完全充填】
  音:  X  X  X  X  X  X  X  X  X  X  X  X
  密度: 100%

【Stage 1: 第1次除去】
  音:  X  X  X  X  X  X  X  X  -  X  X  X
  除去: 拍9
  密度: 92%

【Stage 2: 第2次除去】
  音:  X  X  X  X  X  X  X  X  -  X  X  -
  除去: 拍12
  密度: 83%

[以下同様に逆順で除去]

【Stage 4: 基本パターン回帰】
  音:  X  -  X  -  X  -  X  X  -  X  X  -
  密度: 67%

音楽的効果:
  - クライマックスからの解放
  - 元のパターンへの回帰
  - アーチ形式の完成
\`\`\`

### 5.3 プロセスの時間的展開パラメータ

\`\`\`
各段階の反復回数: R = 12~24回
  → 聴取者がパターンを認識・記憶するに十分な回数

段階遷移時間:
  T_stage = R × (Pattern_length / BPM) × 60
  
  例: Pattern_length = 12拍, R = 18回, BPM = 180
      T_stage = 18 × (12/180) × 60 = 72秒 ≈ 1分12秒

総プロセス時間:
  T_total = N_stages × T_stage
  
  例: N_stages = 5, T_stage = 72秒
      T_total = 360秒 = 6分

段階間遷移:
  タイプA: 即座の置換 (1サイクル内)
  タイプB: 漸進的フェード (2~4サイクル)
  
  ライヒ作品はほぼタイプA
\`\`\`

---

## 6. 結果パターンの生成理論

### 6.1 心理音響学的基盤

**定義**：
結果パターン（Resulting Pattern）とは、複数の反復パターンの重なりから生じる、演奏されていないが知覚される旋律・リズムパターン

**発生メカニズム**：
\`\`\`
1. 聴覚ストリーム分離 (Auditory Stream Segregation)
   - 周波数近接性に基づく音のグループ化
   - 時間的連続性による結合

2. ゲシュタルト原理
   - 近接の法則: 近い音は一つのまとまりとして知覚
   - 類同の法則: 似た音高は同じストリームに属する
   
3. 選択的注意
   - 聴取者の注意が特定の音高系列に焦点化
   - 他の音は背景に退く
\`\`\`

### 6.2 数学的モデル化

**基本定式化**：
\`\`\`
与えられた条件:
  Voice_i(t): 声部iの時刻tにおける音高
  N: 声部数
  θ_i: 声部iの位相（ずれ量）

結果パターン集合:
  RP(t, focus_pitch) = {
    Event(t', p) | 
      ∃i,j: Voice_i(t'+δ_i) = p AND Voice_j(t'+δ_j+θ_j) = p
      AND |δ_i - δ_j| < ε
      AND p ∈ focus_pitch
  }

  where:
    ε = 時間的近接性閾値 (典型: 50ms)
    focus_pitch = 注意焦点となる音高集合
    Event(t', p) = 時刻t'、音高pのイベント

抽出頻度:
  Frequency(p) = Count({Event(t, p) | Event ∈ RP})
  
  頻度が高いほど顕著な結果パターン
\`\`\`

### 6.3 《Piano Phase》における結果パターンカタログ

**位相別の主要結果パターン**：

\`\`\`
【位相0: ユニゾン】
  結果: なし（2台が完全同期）
  知覚: 単一のピアノ音列

【位相1: E-F♯優勢】
  重複音高: F♯(2), E(1), C♯(1)
  結果旋律: F♯-E-C♯ (下降3度)
  顕著度: ★★☆☆☆

【位相2: アルペジオ上昇】
  重複音高: B(2), C♯(2), D(2), F♯(2)
  結果旋律: B-C♯-D-F♯ (Bメジャー・アルペジオ)
  顕著度: ★★★★☆

【位相3: 跳躍パターン】
  重複音高: C♯(3), F♯(3), D(2)
  結果旋律: C♯-F♯-D (4度跳躍)
  顕著度: ★★★☆☆

【位相4: F♯中心】
  重複音高: F♯(4), E(2)
  結果旋律: F♯持続 + E装飾
  顕著度: ★★★★★ (最も顕著)

【位相5: D-F♯振動】
  重複音高: D(3), F♯(2), B(2)
  結果旋律: D-F♯-D-F♯ (振動パターン)
  顕著度: ★★★☆☆

【位相6: 逆位相・複雑】
  重複音高: 少ない (ほぼ相補的)
  結果旋律: 断片的・不明瞭
  顕著度: ★☆☆☆☆

【位相7-11】
  位相1-5の鏡映的パターン
  顕著度も対称的に分布

【位相12: ユニゾン回帰】
  結果: なし（再び完全同期）
\`\`\`

**顕著度の定量化**：
\`\`\`
Salience(θ) = Σ[p ∈ PitchSet] (Frequency(p, θ)² × Melodic_weight(p))

Melodic_weight(p): 
  - 音高pが旋律的に重要な場合に高い値
  - 音域の中央付近で高い（F♯4, B4, C♯5）
  - 音域の両端で低い（E4, D5）

計算結果:
  位相0:  Salience = 0 (ユニゾン)
  位相1:  Salience = 2.1
  位相2:  Salience = 4.3 ★
  位相3:  Salience = 3.2
  位相4:  Salience = 5.8 ★★ (最大)
  位相5:  Salience = 3.5
  位相6:  Salience = 1.2
  ...
  
  ピーク: 位相2, 4 → 聴取体験のハイライト
\`\`\`

### 6.4 《Drumming》における声楽的結果パターン

**女声パートの役割**：
打楽器（マリンバ）の結果パターンを声楽化し、聴取者の注意を誘導

**抽出アルゴリズム詳細**：
\`\`\`python
def extract_vocal_resultant_pattern(marimba_parts, phase_offset):
    """
    3つのマリンバパートから結果パターンを抽出
    
    Args:
        marimba_parts: List of 3 marimba note sequences
        phase_offset: Phase relationship between parts
    
    Returns:
        vocal_melody: Extracted melodic line for voices
    """
    resultant_events = []
    
    for time_unit in range(total_duration):
        # 各時刻で各マリンバが何を演奏しているか
        notes_at_time = []
        for part_id, part in enumerate(marimba_parts):
            adjusted_time = time_unit + phase_offset[part_id]
            note = part[adjusted_time % len(part)]
            notes_at_time.append((part_id, note))
        
        # 同時または近接して鳴る音高を特定
        coincident_pitches = find_coincident_pitches(
            notes_at_time,
            time_window=2  # ±2 time units
        )
        
        # 頻度の高い音高を選択
        if len(coincident_pitches) >= 2:
            most_frequent = max(coincident_pitches, 
                              key=lambda p: coincident_pitches.count(p))
            resultant_events.append((time_unit, most_frequent))
    
    # 旋律的連結（跳躍最小化）
    vocal_melody = connect_melodically(resultant_events, 
                                       max_leap=5)  # 完全4度まで
    
    # リズミック整形
    vocal_melody = quantize_to_pulse(vocal_melody, 
                                     pulse_grid=8)  # 8分音符グリッド
    
    return vocal_melody
\`\`\`

**実際の抽出例（《Drumming》Part II）**：
\`\`\`
時刻 | M1   | M2   | M3   | 重複  | 女声選択
-----|------|------|------|-------|----------
0    | D    | -    | -    | -     | -
1    | F    | D    | -    | -     | -
2    | A    | F    | D    | -     | -
3    | D    | A    | F    | -     | F
4    | F    | D    | A    | D     | D
5    | A    | F    | D    | F,D   | F
6    | C    | A    | F    | A,F   | A
7    | A    | C    | A    | A,A   | A (強調)
8    | D    | A    | C    | A     | A
9    | F    | D    | A    | D,A   | D

女声旋律: F-D-F-A-A-A-D (リズム整形後)
音節割当: Sol-Re-Sol-Do-Do-Do-Re
\`\`\`

---

## 7. ライヒ代表作品の完全解析

### 7.1 《Music for 18 Musicians》（1976）

#### マクロ構造：11和音サイクル

**形式図**：
\`\`\`
総演奏時間: 50~70分
セクション数: 14

構造:
  [Pulses] → [I] → [II] → [IIIA] → [IIIB] → [IV] → [V] → [VI] → 
  [VII] → [VIII] → [IX] → [X] → [XI] → [Pulses]

時間配分:
  Pulses (冒頭): 約5分
  Section I~XI: 各3~6分
  Pulses (終結): 約5分

形式的特徴:
  - アーチ形式: セクションIIIが中心（2部に分割）
  - 対称的時間配分
  - 冒頭と終結でPulsesが枠組みを形成
\`\`\`

**11和音の完全仕様**：
\`\`\`
和音I:    D-F♯-A-C♯     (Dmaj7、5度省略)
和音II:   D-E-F♯-A-C♯   (Dmaj9、5度省略)
和音III:  D-F♯-A-C       (D7)
和音IV:   D-E-F♯-A-C     (D9)
和音V:    D-F♯-A-B       (Bm/D、第1転回)
和音VI:   D-E-F♯-A-B     (Bm9/D)
和音VII:  D-F♯-A-C♯     (和音Iの回帰)
和音VIII: E-G♯-B-D       (Emaj7)
和音IX:   E-F♯-G♯-B-D   (E9)
和音X:    E-G♯-B-C♯     (Emaj7、第6音へ変更)
和音XI:   E-F♯-G♯-B-C♯ (E9、第6音へ変更)

調性分析:
  - 主要調: Dメジャー (和音I~VII)
  - 副次調: Eメジャー (和音VIII~XI)
  - 転調関係: 全音上（D→E）
  - 半音階的音: C, C♯の交替が調性的緊張を生成
  
音階統計:
  使用音高: D, E, F♯, G♯, A, B, C, C♯ (8音)
  基本音階: Dメジャー + 変化音
  シャープ数: 2~4個（常に調号内）
\`\`\`

**Pulsesセクションの機能**：
\`\`\`
演奏時間: 約5分 (冒頭) + 約5分 (終結)

構造:
  - 11和音を順次提示（各20~30秒）
  - ヴィブラフォンが各和音を明瞭に提示
  - 他の楽器が徐々に参入・退出
  - 和音間の移行は瞬時

役割:
  1. 楽曲全体の「和声地図」を提供
  2. 聴取者に構造の見通しを与える
  3. 終結時に循環性を示す（冒頭への回帰）
  
音楽的類比:
  - バロック音楽のリトルネロ
  - ラーガ音楽のアラープ（序奏）
\`\`\`

#### 楽器編成と役割分担

**完全楽器リスト（18~21名）**：
\`\`\`
【パルス楽器】(リズム基盤)
  - ヴィブラフォン × 1 (指揮的役割)
  - マリンバ × 3
  - シロフォン × 2 (ライヒ作品初使用)
  - ピアノ × 4 (うち2台はミュート・プリペアード)

【持続音楽器】(和声基盤)
  - 女声 × 4 (ソプラノ)
  - ヴァイオリン × 2
  - チェロ × 1

【管楽器】(旋律・装飾)
  - クラリネット × 2 (B♭クラリネット + バス・クラリネット)

総数: 最小18名、最大21名
\`\`\`

**機能的役割分担**：
\`\`\`
【レイヤー1: パルス層】
  担当: マリンバ、シロフォン、ピアノ
  機能: 8分音符または16分音符の不変パルス
  パターン: アルペジオ的上下行
  ダイナミクス: mf~f (常に明瞭)
  
  具体例（Section I、Dメジャー和音）:
    Marimba 1: D-F♯-A-F♯-D-F♯-A-F♯ (8分音符)
    Marimba 2:   F♯-A-D-A-F♯-A-D-A (位相ずれ)
    Marimba 3:     A-D-F♯-D-A-D-F♯-D

【レイヤー2: 和声層】
  担当: 女声、ヴァイオリン、チェロ、クラリネット
  機能: 和音の長音保持 (1~4小節)
  呼吸パターン: 交替呼吸（各奏者が独立）
  ダイナミクス: p~mp (背景的)
  
  実装:
    Voice 1: C♯持続 (4拍) → 呼吸 (2拍) → C♯持続 (4拍)
    Voice 2:         呼吸 → A持続 (4拍) → 呼吸
    [他の奏者も交替でずれる]
    
    → 和声が途切れず持続する効果

【レイヤー3: 旋律層】
  担当: ヴィブラフォン、ピアノ(部分的)
  機能: 結果パターンの強調、セクション間の橋渡し
  パターン: パルス層より遅いリズム (4分音符~2分音符)
  ダイナミクス: mp~mf
\`\`\`

#### セクション別詳細分析

**【Section I】（約5分30秒）**
\`\`\`
和音: I (D-F♯-A-C♯)
プロセス: 段階的置換

構造:
  Phase A (2分): 基本パルスパターン確立
    - マリンバのアルペジオ開始
    - 女声・弦が徐々に参入
    
  Phase B (2分): 密度増大
    - クラリネット参入
    - パルスパターンに装飾音追加
    
  Phase C (1分30秒): ピーク
    - 全楽器が最大密度
    - ヴィブラフォンが旋律的フレーズ
    
  Phase D (移行): 次のセクションへフェード

音高統計:
  最頻音: A (40%), F♯ (30%), D (20%), C♯ (10%)
  → Aが「ドローン」的に機能
\`\`\`

**【Section V】（約4分）**
\`\`\`
和音: V (D-F♯-A-B) → 短調領域への移行

特徴:
  - 唯一の「暗い」セクション
  - Bマイナー的な響き（D-F♯-Aがトニック、Bが第6音）
  - テンポ感覚が遅く感じられる
  
音色変化:
  - バス・クラリネット強調
  - チェロの低音域使用
  - 女声の音域が下降

機能:
  - 楽曲全体の「谷」部分
  - 対比によりセクションVIIIの明るさを強調
\`\`\`

**【Section IIIA/IIIB】（約6分+6分=12分）**
\`\`\`
和音: III, IV (D7系統)

構造的重要性:
  - 楽曲の正確な中心点
  - 最長セクション（2部に分割）
  - 最も複雑なポリリズム

プロセス:
  IIIA: 3対2のポリリズム確立
  IIIB: 4対3のポリリズム展開
  
時間的対称性:
  Pulses → I → II → IIIA → [中心] ← IIIB ← IV ← V ← ... ← Pulses
\`\`\`

#### 呼吸パターンの精密設計

**交替呼吸システム**：
\`\`\`
問題: 持続音楽器は呼吸が必要 → 和声が途切れる

解決: 時間差をつけて交替で呼吸

実装 (女声4人の例):
  時刻 | V1    | V2    | V3    | V4    | 結果
  -----|-------|-------|-------|-------|----------
  0-4  | 歌う  | 歌う  | 歌う  | 呼吸  | 和音継続
  4-8  | 歌う  | 歌う  | 呼吸  | 歌う  | 和音継続
  8-12 | 歌う  | 呼吸  | 歌う  | 歌う  | 和音継続
  12-16| 呼吸  | 歌う  | 歌う  | 歌う  | 和音継続
  
  → 常に3人以上が歌唱 → 和声が途切れない

数学的記述:
  N_voices = 4
  Min_active = 3
  Breath_duration = 4拍
  Active_duration = 12拍
  
  Cycle_length = Breath_duration × N_voices = 16拍
  
  Voice_i_phase = (i-1) × Breath_duration
  Voice_i_active(t) = 1 if (t - Voice_i_phase) mod Cycle_length >= Breath_duration
                       0 otherwise
  
  Σ Voice_i_active(t) >= Min_active  (∀t)
\`\`\`

### 7.2 《Six Pianos》（1973）

**概要**：
\`\`\`
編成: ピアノ6台（または5台+マリンバ）
演奏時間: 20~25分
技法: 段階的カノン + 加算的プロセス
\`\`\`

**構造分析**：
\`\`\`
基本パターン: 8音
  C-D-E-F-G-A-B-C (Cメジャースケール、1オクターブ)

プロセス:
  Phase 1: ピアノ1が基本パターン開始
  Phase 2: ピアノ2が1拍遅れて参入 (カノン)
  Phase 3: ピアノ3が2拍遅れて参入
  Phase 4: ピアノ4が3拍遅れて参入
  Phase 5: ピアノ5が4拍遅れて参入
  Phase 6: ピアノ6が5拍遅れて参入
  
  → 6声のカノンが形成
  
  Phase 7~15: 段階的置換により音符追加
  Phase 16~20: 最大密度を維持
  Phase 21~25: 段階的減少（対称的）

カノン間隔:
  固定1拍 (8分音符単位)
  → 全体として6拍 = 1.5小節の遅延キャノン
\`\`\`

**音響効果**：
\`\`\`
初期: 単純なC majorスケール上行
中期: 6台のピアノが複雑なポリフォニー形成
後期: 音響的な「雲」、個々のラインが判別不能

知覚的変化:
  - 明瞭なメロディ → 和声的塊 → 音色的質感
  - ライヒの「結果パターン」が極端に複雑化
\`\`\`

### 7.3 《Variations for Winds, Strings and Keyboards》（1979）

**概要**：
\`\`\`
編成: 大編成オーケストラ
  - フルート、オーボエ、クラリネット
  - トランペット、トロンボーン
  - 弦楽器群
  - ピアノ、電気オルガン
  
演奏時間: 約30分
技法: 和声的変奏 + 複合ポリリズム
\`\`\`

**和声システム**：
\`\`\`
基本和音: Dマイナー
変奏和音: D-F-A → D-F-A-C → D-F-A-C-E → ...

ライヒ作品における初の長時間和声進行:
  Section 1: Dm
  Section 2: Dm7
  Section 3: Dm9
  Section 4: Fmaj7
  Section 5: Am7
  ...
  
  → 従来の静的和声から動的和声へ進化
\`\`\`

**ポリリズムの複雑化**：
\`\`\`
同時進行リズム層:
  Layer 1: 8分音符 (基準パルス)
  Layer 2: 3連符
  Layer 3: 5連符
  Layer 4: 7連符
  
数学的関係:
  LCM(2, 3, 5, 7) = 210
  → 210個の16分音符後に全層が再同期
  → 約26.25拍 ≈ 6.5小節
  
聴覚的効果:
  - 極めて複雑なリズム的テクスチャ
  - 「時間」の多層的知覚
\`\`\`

---

# 第III部：フィリップ・グラスの技法

## 8. 加算的構造（グラス版）の理論

### 8.1 グラス型加算プロセスの定義

**ライヒとの相違点**：
\`\`\`
┌─────────────────┬──────────────────┬──────────────────┐
│ 特徴            │ ライヒ           │ グラス           │
├─────────────────┼──────────────────┼──────────────────┤
│ 変化対象        │ 音符/休符の置換  │ パターン長の変化 │
│ パターン長      │ 固定             │ 可変             │
│ 変化単位        │ 1音             │ 1~4音            │
│ 予測可能性      │ 高 (決定論的)    │ 中 (作曲的)      │
│ 対称性          │ 高 (70~90%)      │ 低 (20~40%)      │
└─────────────────┴──────────────────┴──────────────────┘
\`\`\`

**グラス型加算プロセスの数学的定義**：
\`\`\`
初期パターン: P₀ = [n₁, n₂, ..., nₖ]  (長さk)
加算操作: P_{i+1} = P_i + Δ_i         (Δ_i = 追加される音符群)

追加規則:
  1. 追加位置: パターン末尾または内部の特定位置
  2. 追加音数: 1~4音 (典型的には2音)
  3. 追加音高: 既存音高集合から選択
  4. 旋律的連続性: 跳躍を最小化

例：《Einstein on the Beach》のトレイン場面
  P₀ = [C, D, E]                    (長さ3)
  P₁ = [C, D, E, F, E]              (長さ5, +2音)
  P₂ = [C, D, E, F, E, D, E]        (長さ7, +2音)
  P₃ = [C, D, E, F, E, D, E, F, G]  (長さ9, +2音)
  ...
  P_n = [C, D, E, F, E, D, E, F, G, F, E, D, E, F, G, A]

特徴:
  - パターン長が等差数列的に増加
  - 音高は段階的動きが優勢
  - 対称性は低い（後半は前半の反復ではない）
\`\`\`

### 8.2 《Einstein on the Beach》（1976）の分析

**全体構造**：
\`\`\`
総演奏時間: 約4時間30分~5時間
形式: オペラ（ただし劇的展開なし）
セクション数: 9シーン + 5つのKnee Plays

構成:
  Knee Play 1
  → Train 1
  Knee Play 2
  → Trial 1
  Knee Play 3
  → Field/Spaceship
  Knee Play 4
  → Train 2
  Knee Play 5
  → Trial 2/Prison
  → Dance 1
  → Dance 2
  → Spaceship

特徴:
  - 幕間なし (連続上演)
  - 観客の出入り自由
  - ナラティブなし (抽象的イメージの連鎖)
\`\`\`

**Knee Playsの音楽構造**：
\`\`\`
編成: 女声2 + ヴァイオリン + 電子オルガン

基本パターン (Knee Play 1):
  数字カウント: 1-2-3-4, 1-2-3-4-5, 1-2-3-4-5-6, ...
  音高: C-D-E-F-G-A (Cメジャー、6音)
  
加算的展開:
  Phrase 1: [1 2 3 4]
  Phrase 2: [1 2 3 4 5]
  Phrase 3: [1 2 3 4 5 6]
  Phrase 4: [1 2 3 4 5 6 7]
  Phrase 5: [1 2 3 4 5 6 7 8]
  ...
  最終: [1 2 3 4 5 6 7 8 9 10 ... 26]

音楽的実装:
  各数字が1音符に対応
  音高は上記C-D-E-F-G-Aを循環使用
  
  例: "1 2 3 4 5 6"
  音高: C-D-E-F-G-A
  
  "1 2 3 4 5 6 7 8"
  音高: C-D-E-F-G-A-C-D (2周目に入る)

テンポ: ♩= 120~140 BPM
反復: 各フレーズを8~16回反復後、次へ
\`\`\`

**Train場面の加算的構造**：
\`\`\`
基本モチーフ:
  [C E C D]

段階的展開:
  Pattern 1: [C E C D]                (長さ4)
  Pattern 2: [C E C D E C]            (長さ6)
  Pattern 3: [C E C D E C D E]        (長さ8)
  Pattern 4: [C E C D E C D E C D]    (長さ10)
  Pattern 5: [C E C D E C D E C D E C D E] (長さ14)
  ...

音高集合: {C, D, E} (3音のみ)
リズム: 16分音符連続
ダイナミクス: f~ff (強烈な持続)
演奏時間: 約20分（各パターン）

音響効果:
  - 列車の単調な走行音を模倣
  - 催眠的・トランス的効果
  - 「ミニマル」の極限表現
\`\`\`

### 8.3 《Glassworks》（1982）の構造分析

**概要**：
\`\`\`
編成: 小編成アンサンブル
  - サクソフォン(ソプラノ、アルト)
  - フルート
  - 2台の電子オルガン
  - シンセサイザー

楽章構成:
  1. Opening (6:30)
  2. Floe (6:35)
  3. Island (7:25)
  4. Rubric (6:25)
  5. Facade (7:10)
  6. Closing (5:18)

総演奏時間: 約40分
\`\`\`

**第1楽章 "Opening" の詳細**：
\`\`\`
調: Aマイナー
拍子: 4/4
テンポ: ♩= 96 BPM

基本パターン (低音):
  A - G - F - E (下降4度)
  反復: 連続（全曲を通して）

上声パターン (加算的):
  Pattern 1: [A C E]          (Amコードアルペジオ)
  Pattern 2: [A C E A G]      (+2音)
  Pattern 3: [A C E A G F E]  (+2音)
  Pattern 4: [A C E A G F E G F E D] (+4音)
  ...

和声進行:
  Am → G → F → E (繰り返し)
  → フリギア旋法的響き
  
テクスチャ:
  - 低音: オスティナート
  - 中音: アルペジオ
  - 高音: 持続音 (サックス、フルート)
\`\`\`

### 8.4 加算/減算の対称的構造

**アーチ形式の実装**：
\`\`\`
グラス作品の多くは加算→減算の対称構造

例：《Glassworks》"Floe"
  
  [導入] (1分)
    基本パターン (5音)
    ↓
  [加算部] (3分)
    5音 → 7音 → 9音 → 11音 → 13音 (クライマックス)
    ↓
  [減算部] (2分30秒)
    13音 → 11音 → 9音 → 7音 → 5音
    ↓
  [コーダ] (30秒)
    基本パターン回帰

時間的対称性:
  加算部 ≈ 減算部 (ほぼ同じ時間)
  
音楽的効果:
  - 明確な頂点 (最長パターン)
  - 構造的完結性
  - 聴取者に安心感を与える
\`\`\`

---

## 9. 和声循環システム

### 9.1 グラス和声の基本原理

**特徴**：
\`\`\`
1. 機能和声の否定
   - I-IV-V-I のような機能的進行は避ける
   - 代わりに「和音循環」を使用

2. 少数和音のループ
   - 典型的には3~5和音
   - 短い循環 (4~8小節)
   - 数十回~数百回反復

3. 共通音保持
   - 和音間で1~2音を保持
   - 滑らかな移行
   - 「浮遊感」の創出

4. モード的色彩
   - ドリアン、フリギアなどの教会旋法
   - ペンタトニック
   - 音階外音は限定的
\`\`\`

### 9.2 代表的和声進行パターン

**【3和音サイクル】**
\`\`\`
パターンA: I - ♭VII - ♭VI
  例 (C major基準): C - B♭ - A♭
  
  調性: Cフリギア的
  共通音: なし（パラレル）
  効果: エキゾチック、暗い

パターンB: i - ♭VII - ♭VI - ♭VII
  例 (A minor基準): Am - G - F - G
  
  調性: Aエオリアン
  共通音: G (コード2と4)
  効果: 民族音楽的

パターンC: I - V - vi - IV
  例: C - G - Am - F
  
  調性: Cメジャー
  共通音: C (コード1と3), G (コード2と4)
  効果: 明るい、ポップス的
\`\`\`

**【4和音サイクル】**
\`\`\`
パターンD: i - ♭III - ♭VII - ♭VI
  例 (D minor): Dm - F - C - B♭
  
  調性: Dドリアン
  共通音: F (コード1と2), C (コード2と3)
  効果: 中世的、瞑想的

パターンE: I - ii - IV - V
  例: F - Gm - B♭ - C
  
  調性: Fメジャー
  共通音: 多数
  効果: 古典的、安定

パターンF: i - iv - ♭VII - ♭III
  例 (E minor): Em - Am - D - G
  
  調性: Eエオリアン
  共通音: E (コード1), D (コード3と4)
  効果: フォーク的
\`\`\`

**【5和音サイクル】**
\`\`\`
パターンG: i - ♭VII - ♭VI - ♭VII - i
  例 (A minor): Am - G - F - G - Am
  
  構造: 対称的 (回文構造)
  調性: Aエオリアン
  効果: 強い循環感

パターンH: I - V - vi - IV - I
  例: C - G - Am - F - C
  
  構造: 明確な開始/終止
  調性: Cメジャー
  効果: 完結性、安定
\`\`\`

### 9.3 《Koyaanisqatsi》（1982）の和声分析

**映画音楽としての特徴**：
\`\`\`
作曲目的: ゴッドフリー・レジオ監督の映画音楽
上映時間: 約86分
音楽構成: 全編がグラスの音楽（途切れなし）
\`\`\`

**"The Grid" の和声構造**：
\`\`\`
編成: オーケストラ + 合唱 + 電子楽器
テンポ: ♩= 132 BPM (急速)
拍子: 4/4

和声進行 (16小節サイクル):
  | Dm    | Dm    | Gm    | Gm    |
  | C     | C     | F     | F     |
  | B♭    | B♭    | Am    | Am    |
  | Dm    | Dm    | Dm    | Dm    |

分析:
  - 調: Dドリアン
  - サイクル長: 16小節 = 約7.3秒 (♩=132)
  - 反復回数: 約40回 (映画シーンの長さに依存)
  
  和音機能 (ドリアンにおける):
    Dm (i):  トニック
    Gm (iv): サブドミナント
    C (♭VII): 下属短7度
    F (♭III): 短3度
    B♭ (♭VI): 短6度
    Am (v):  ドミナント（短）
    
  → 機能和声ではなく、モーダルな音響空間

視覚との対応:
  - 和音変化 ≈ 画面の視覚的切り替わり
  - 加速的リズム ≈ 都市の喧騒
  - 反復的構造 ≈ 現代社会の機械性
\`\`\`

**"Prophecies" の和声構造**：
\`\`\`
テンポ: ♩= 96 BPM (中庸)
拍子: 6/8

和声進行 (8小節サイクル):
  | Em    | D     | C     | D     |
  | Em    | D     | C     | Bm    |

分析:
  - 調: Eエオリアン (自然短音階)
  - サイクル長: 8小節 = 約15秒
  - 特徴: コード2と4でD音が「ピヴォット」
  
  和音機能:
    Em (i):  トニック
    D (♭VII): 下属短7度
    C (♭VI): 短6度
    Bm (v):  ドミナント（短）
    
  色彩的効果:
    - Em-D-C: 下降進行 (重力感)
    - C-D: 上昇（期待感）
    - D-Bm: 半終止的（未解決）
    
  → 「予言」というテーマの暗示性・不確定性を表現
\`\`\`

### 9.4 和声サイクルのMIDI実装

\`\`\`python
class GlassHarmonicCycle:
    def __init__(self, progression_type='4chord_cycle'):
        self.progression_type = progression_type
        self.chord_progressions = {
            '3chord_cycle': ['Dm', 'C', 'Bb'],
            '4chord_cycle': ['Dm', 'F', 'C', 'Bb'],
            '5chord_cycle': ['Am', 'G', 'F', 'G', 'Am'],
        }
    
    def generate_chord_sequence(self, num_cycles=8):
        """
        和声サイクルを生成
        
        Args:
            num_cycles: サイクル反復回数
        
        Returns:
            List of chord dictionaries
        """
        base_progression = self.chord_progressions[self.progression_type]
        chord_sequence = []
        
        for cycle in range(num_cycles):
            for chord_symbol in base_progression:
                chord_notes = self._symbol_to_notes(chord_symbol)
                chord_sequence.append({
                    'symbol': chord_symbol,
                    'notes': chord_notes,
                    'duration': 4,  # 4拍（1小節 in 4/4）
                    'cycle': cycle,
                    'position': base_progression.index(chord_symbol)
                })
        
        return chord_sequence
    
    def _symbol_to_notes(self, chord_symbol):
        """和音記号をMIDI音高に変換"""
        chord_dict = {
            # Major chords
            'C': [60, 64, 67],       # C-E-G
            'F': [65, 69, 72],       # F-A-C
            'G': [67, 71, 74],       # G-B-D
            'Bb': [58, 62, 65],      # Bb-D-F
            
            # Minor chords
            'Am': [57, 60, 64],      # A-C-E
            'Dm': [62, 65, 69],      # D-F-A
            'Em': [64, 67, 71],      # E-G-B
            'Gm': [67, 70, 74],      # G-Bb-D
            'Bm': [71, 74, 78],      # B-D-F#
        }
        return chord_dict.get(chord_symbol, [60, 64, 67])
    
    def generate_arpeggio_pattern(self, chord_notes, pattern_type='ascending'):
        """
        和音からアルペジオパターンを生成
        
        Args:
            chord_notes: MIDI音高のリスト
            pattern_type: 'ascending', 'descending', 'alternating'
        
        Returns:
            アルペジオ音高配列
        """
        if pattern_type == 'ascending':
            return chord_notes + [chord_notes[-1] + 12]
        elif pattern_type == 'descending':
            return list(reversed(chord_notes)) + [chord_notes[0] - 12]
        elif pattern_type == 'alternating':
            return [chord_notes[0], chord_notes[2], 
                    chord_notes[1], chord_notes[2]] * 2
        else:
            return chord_notes
\`\`\`

---

## 10. 拍子変化とポリリズム

### 10.1 加算拍子の理論

**定義**：
加算拍子とは、2拍子・3拍子の組み合わせによって形成される非対称的拍子

**グラスの加算拍子使用例**：
\`\`\`
5/8 = 3+2 または 2+3
7/8 = 3+2+2 または 2+2+3 または 2+3+2
11/8 = 3+2+3+3 または 2+3+2+2+2
13/8 = 3+2+2+3+3 または 3+3+3+2+2

実装例 (5/8):
  パターンA: X x X x x
    (X = 強拍、x = 弱拍)
    グループ化: [X x X] [x x] = 3+2
  
  パターンB: X x x X x
    グループ化: [X x x] [X x] = 3+2 (違う位置)
  
  パターンC: X x X x x
    グループ化: [X x] [X x x] = 2+3
\`\`\`

**知覚的効果**：
\`\`\`
対称拍子 (4/4, 3/4):
  - 予測可能
  - 身体的同期容易
  - 西洋音楽の標準

加算拍子 (5/8, 7/8):
  - 予測困難
  - 身体的不安定感
  - 非西洋音楽的（バルカン、中東）
  - ダンス音楽との親和性
\`\`\`

### 10.2 《Dance Pieces》における拍子構造

**概要**：
\`\`\`
作品群: Dance I~IX (1979)
編成: 電子オルガン + 管楽器
特徴: 各ダンスが異なる拍子を使用
\`\`\`

**拍子カタログ**：
\`\`\`
Dance I: 7/8 (2+2+3)
  基本リズム: X x X x X x x
  テンポ: ♪= 168 BPM
  効果: 跛行的、不均等

Dance II: 5/8 (3+2)
  基本リズム: X x x X x
  テンポ: ♪= 152 BPM
  効果: 急速、駆け足

Dance III: 11/8 (2+2+3+2+2)
  基本リズム: X x X x X x x X x X x
  テンポ: ♪= 144 BPM
  効果: 複雑、精巧

Dance IV: 4/4 → 5/8 → 6/8 (拍子変化あり)
  Section A (2分): 4/4 (安定)
  Section B (3分): 5/8 (加速感)
  Section C (2分): 6/8 (流動的)
  効果: 拍子変化による劇的展開

Dance V: 9/8 (3+3+3)
  基本リズム: X x x X x x X x x
  テンポ: ♪= 132 BPM
  特殊: 3拍子系（例外的）
\`\`\`

### 10.3 ポリリズムの実装

**定義**：
複数の異なるリズムパターンが同時進行する技法

**グラス作品におけるポリリズム**：
\`\`\`
【2対3のポリリズム】
  Layer 1 (2連):  X - X - X - X -  (4音/2拍)
  Layer 2 (3連):  Y - - Y - - Y -  (3音/2拍)
  
  最小公倍数: 6
  → 6個の16分音符後に再同期

【3対4のポリリズム】
  Layer 1 (3連):  A - - A - - A - - A - -  (4音/4拍)
  Layer 2 (4連):  B - B - B - B -  (4音/4拍)
  
  最小公倍数: 12
  → 12個の16分音符後に再同期

【5対4のポリリズム】
  Layer 1 (5連):  X - - - - X - - - - X - - - - X - - - - X - - - -
  Layer 2 (4連):  Y - - Y - - Y - - Y - -
  
  最小公倍数: 20
  → 20個の最小単位後に再同期
\`\`\`

**《Glassworks》"Island" のポリリズム分析**：
\`\`\`
基本テンポ: ♩= 84 BPM
拍子: 4/4

Layer 1 (低音): 付点4分音符 (3:2)
  |C . . . . .|. G . . . .|. C . . . .|
  リズム値: ♩. (3拍相当を2等分)
  
Layer 2 (中音): 8分音符 (均等)
  |C D E G C D|E G C D E G|...
  リズム値: ♪
  
Layer 3 (高音): 16分音符3連符
  |C E G C E G C E G C E G|...
  リズム値: 16分音符3連符

数学的関係:
  Layer 1: 周期 = 3拍
  Layer 2: 周期 = 0.5拍
  Layer 3: 周期 = 0.375拍 (16分音符3連符)
  
  LCM(3, 0.5, 0.375) = 3拍
  → 3拍ごとに全層が再同期

聴覚的効果:
  - 3つの時間感覚が同時進行
  - リズム的密度の段階化
  - 「島」のイメージ (層状の地層)
\`\`\`

### 10.4 拍子変化の実装パターン

**パターンA: 段階的拍子増加**
\`\`\`
使用例: 《Einstein on the Beach》Knee Plays

構造:
  Section 1 (2分): 3/4
  Section 2 (2分): 4/4
  Section 3 (2分): 5/4
  Section 4 (2分): 6/4
  ...

効果:
  - 徐々に拡大する時間感覚
  - 「開いていく」イメージ
\`\`\`

**パターンB: 交替拍子**
\`\`\`
使用例: 《Music in Twelve Parts》Part I

構造:
  | 4/4 | 4/4 | 5/8 | 5/8 |
  | 4/4 | 4/4 | 5/8 | 5/8 | (反復)

効果:
  - 規則的だが非対称
  - 2種類の時間感覚の対比
\`\`\`

**パターンC: ランダム的拍子変化**
\`\`\`
使用例: 《Satyagraha》Act II

構造:
  | 7/8 | 5/8 | 7/8 | 6/8 | 7/8 | 5/8 | ...

規則:
  - 7/8が最頻 (基準拍子)
  - 5/8, 6/8が不規則に挿入
  - パターンの予測不可能性

効果:
  - 聴取者の期待を裏切る
  - 緊張感の維持
\`\`\`

---

## 11. グラス代表作品の完全解析

### 11.1 《Music in Twelve Parts》（1971-74）

**概要**：
\`\`\`
演奏時間: 約4時間
構成: 12のパート（各パート約20分）
編成: 
  - 電子オルガン × 2
  - フルート × 2 (Part 12のみ)
  - サクソフォン (Part 12のみ)

歴史的意義:
  - グラス初期様式の集大成
  - 演奏時間の長大化の始まり
  - オペラ作品への橋渡し
\`\`\`

**Part I の詳細分析**：
\`\`\`
調: Cメジャー/Aマイナー (曖昧)
拍子: 主に4/4、部分的に5/8
テンポ: ♩= 120 BPM

基本パターン:
  Voice 1: [C E G E C E G E]
  Voice 2: [E G C G E G C G] (位相ずれ)
  
  → ライヒ的フェイジングの痕跡
  
加算的展開 (10分経過後):
  Pattern 1: [C E G E C E G E]
  Pattern 2: [C E G E C E G E A G]
  Pattern 3: [C E G E C E G E A G F E]
  Pattern 4: [C E G E C E G E A G F E D C]
  
  → グラス様式への移行

和声進行 (後半):
  | C  | Am | F  | G  |
  | C  | Am | F  | G  | (8小節サイクル)
  
  → 明確な和声循環の導入
\`\`\`

**Part XII の構造**：
\`\`\`
最終パート、全楽器参加

特徴:
  1. フルート、サクソフォン追加
  2. 最も複雑な音価関係
  3. 12のパートすべての要素を統合

音価の重層:
  - オルガン1: 16分音符
  - オルガン2: 8分音符3連符
  - フルート: 付点8分音符
  - サックス: 4分音符
  
  → 4層のポリリズム

数学的関係:
  LCM(16分, 8分3連, 付点8分, 4分) = 48
  → 48個の最小単位(64分音符)後に再同期
  → 約3拍/1サイクル (♩=120)

効果:
  - 極度のリズム的複雑性
  - 個々のラインは単純だが、全体は複雑
  - グラス技法の最高到達点（初期様式）
\`\`\`

### 11.2 《Satyagraha》（1980）

**概要**：
\`\`\`
形式: オペラ（3幕）
演奏時間: 約2時間40分
題材: マハトマ・ガンディーの南アフリカ時代
言語: サンスクリット語 (バガヴァッド・ギーター)
初演: 1980年、ロッテルダム

編成:
  - 大編成オーケストラ
  - 合唱
  - ソリスト (ガンディー役はテノール)
\`\`\`

**音楽的特徴**：
\`\`\`
【和声システム】
調的中心: Dマイナー/Dドリアン
和声進行: モーダル（機能和声なし）

代表的進行 (Act I):
  | Dm | C | Bb | A |
  | Dm | C | Bb | A | (4小節サイクル)
  
  → ドリアン・モードの循環

【リズム構造】
拍子: 変動 (7/8, 5/8, 4/4の混合)
テンポ: ♩= 132~168 BPM (場面により変化)

加算拍子の使用 (Act II, Scene 2):
  | 7/8 | 7/8 | 5/8 | 7/8 |
  | 7/8 | 5/8 | 7/8 | 6/8 |
  
  → 不規則だが推進力のあるリズム

【テクスチャ】
- 弦楽器: アルペジオ反復 (16分音符)
- 管楽器: 和声保持 + 装飾
- 合唱: テキスト詠唱 (リズミック)
- ソロ: 旋律的ライン (声楽的)

層構造:
  低層: 低弦のオスティナート
  中層: アルペジオ群
  高層: 旋律・声楽
\`\`\`

**Act III, Finale の分析**：
\`\`\`
場面: ガンディーの精神的覚醒

音楽構造:
  Duration: 約18分
  Section数: 3 (A-B-A' 形式)

【Section A】(6分)
  和声: | Dm | F | C | Gm |
  テンポ: ♩= 144 BPM
  テクスチャ: 全楽器参加、最大密度
  
【Section B】(6分)
  和声: | Em | D | C | Bm | (転調)
  テンポ: ♩= 132 BPM (やや遅く)
  テクスチャ: 弦楽器のみ、瞑想的
  
【Section A'】(6分)
  和声: | Dm | F | C | Gm | (回帰)
  テンポ: ♩= 144 BPM (回復)
  テクスチャ: 全楽器再参加、高揚

クライマックス:
  - 全合唱の"Om" (最高音G5)
  - オーケストラの最大音量 (fff)
  - 和音: Dメジャー (短調からの解放)
  - 持続時間: 約30秒

終結:
  - 徐々に音楽が静まる
  - 最後は低弦のD音のみ (pppp)
  - 「静寂への回帰」
\`\`\`

### 11.3 《Akhnaten》（1983）

**概要**：
\`\`\`
形式: オペラ（3幕）
演奏時間: 約2時間30分
題材: 古代エジプト王アクエンアテン
言語: 古代エジプト語、ヘブライ語、アッカド語

特殊編成:
  - オーケストラ: ヴァイオリンなし（異例）
  - 強調楽器: ヴィオラ、チェロ、低音楽器
  - 主役: カウンターテナー（非常に高い男声）
  
  → 古代の「異質性」を音色で表現
\`\`\`

**音楽的革新**：
\`\`\`
【低音重視の音響】
編成の特徴:
  - 第1ヴァイオリン: なし
  - 第2ヴァイオリン: なし
  - ヴィオラ: 増強 (8~10名)
  - チェロ: 増強 (8~10名)
  - コントラバス: 標準 (6~8名)
  - ホルン、トロンボーン: 増強
  
  → 重心が低く、暗い音色
  → 「地下」「墓」「神秘」のイメージ

【和声の特殊性】
調: Eマイナー/Eフリギアが中心
  → 古代性、エキゾチシズム

代表的和声進行 (Act II, Hymn):
  | Em | D | C | B |
  | Em | D | C | B | (4小節サイクル)
  
  分析:
    - Em (i): トニック
    - D (♭VII): 下属短7度
    - C (♭VI): 短6度
    - B (V): ドミナント（短3和音ではない）
  
  → フリギア的下降進行

【リズムの特徴】
拍子: 4/4が主体（ただし内部律動は複雑）
テンポ: ♩= 96~120 BPM (比較的遅い)

特殊リズム (Act III, Dance):
  5対4のポリリズム:
    Percussion: 5拍子
    Strings: 4拍子
    
    → 20拍で再同期
    → 約5小節 (4/4拍子)
\`\`\`

**Act III, Epilogue の構造**：
\`\`\`
場面: アクエンアテン王の遺跡を訪れる現代の観光客

音楽的役割:
  - 古代と現代の対比
  - 時間の循環性

構造:
  【Part A】古代の音楽 (5分)
    - オーケストラ: 全編成
    - 合唱: 古代エジプト語
    - 和声: Em-D-C-B (反復)
    
  【Part B】移行 (2分)
    - 音楽が徐々に変容
    - テンポ減速: ♩= 96 → 72
    - 楽器が徐々に退出
    
  【Part C】現代の音楽 (3分)
    - オーケストラ: 弦楽器のみ
    - 語り: 英語（観光ガイドの説明）
    - 和声: C-G-Am-F (現代的)
    
  【Part D】融合 (3分)
    - 古代と現代の音楽が重層
    - 二重の時間感覚
    - 終結: 静寂へフェード

哲学的意味:
  - 過去は永遠に繰り返す
  - 人間の営みの普遍性
  - ミニマリズム音楽の「循環」哲学の究極表現
\`\`\`

---

# 第IV部：実装技術

## 12. 音高システムと音階理論

### 12.1 ミニマリズム音楽で使用される音階

**【ペンタトニック音階】**
\`\`\`
定義: 5音音階

Major Pentatonic:
  C Pentatonic: C - D - E - G - A
  音程構造: 全音 - 全音 - 短3度 - 全音 - 短3度
  
  特徴:
    - 明るい、開放的
    - 半音なし → 不協和音が生じにくい
    - ライヒ初期作品に頻出

Minor Pentatonic:
  A Pentatonic: A - C - D - E - G
  音程構造: 短3度 - 全音 - 全音 - 短3度 - 全音
  
  特徴:
    - やや暗い、落ち着いた
    - ブルース的響き
    
使用例:
  - ライヒ《Piano Phase》: Bメジャー・ペンタトニック
  - ライヒ《Music for 18 Musicians》: 部分的にペンタトニック
\`\`\`

**【教会旋法 (Church Modes)】**
\`\`\`
Dorian (ドリアン):
  D Dorian: D - E - F - G - A - B - C
  音程: 全 - 半 - 全 - 全 - 全 - 半 - 全
  特徴: 短調的だが明るさあり
  
  使用例:
    - グラス《Glassworks》"Opening"
    - グラス《Satyagraha》

Phrygian (フリギア):
  E Phrygian: E - F - G - A - B - C - D
  音程: 半 - 全 - 全 - 全 - 半 - 全 - 全
  特徴: エキゾチック、スペイン的
  
  使用例:
    - グラス《Akhnaten》
    - グラス《Koyaanisqatsi》

Mixolydian (ミクソリディアン):
  G Mixolydian: G - A - B - C - D - E - F
  音程: 全 - 全 - 半 - 全 - 全 - 半 - 全
  特徴: 長調的だがやや民族的
  
  使用例:
    - ライヒ《Music for Mallet Instruments》

Aeolian (エオリアン) = Natural Minor:
  A Aeolian: A - B - C - D - E - F - G
  音程: 全 - 半 - 全 - 全 - 半 - 全 - 全
  特徴: 標準的短音階
  
  使用例:
    - グラス《Music in Twelve Parts》
\`\`\`

**【ダイアトニック音階】**
\`\`\`
Major Scale:
  C Major: C - D - E - F - G - A - B
  音程: 全 - 全 - 半 - 全 - 全 - 全 - 半
  
  使用例:
    - ライヒ《Six Pianos》
    - グラス《Einstein on the Beach》Knee Plays

Harmonic Minor:
  A Harmonic Minor: A - B - C - D - E - F - G♯
  音程: 全 - 半 - 全 - 全 - 半 - (増2度) - 半
  
  特徴: G♯が特徴的（導音）
  使用: 限定的（主に古典的文脈）

Melodic Minor:
  A Melodic Minor (上行): A - B - C - D - E - F♯ - G♯
  音程: 全 - 半 - 全 - 全 - 全 - 全 - 半
  
  使用: 非常に限定的
\`\`\`

### 12.2 音階選択のガイドライン

**ライヒ作品における音階選択**：
\`\`\`
推奨順位:
  1. Pentatonic (Major または Minor)
     - 最も安全、不協和音少ない
     - 初期作品の標準
  
  2. Diatonic Major
     - 明るい、開放的
     - 《Six Pianos》等で使用
  
  3. Mixolydian
     - やや民族的
     - 中期作品で増加
  
避けるべき:
  - Chromatic (半音階)
  - Whole Tone (全音音階)
  - Synthetic Scales (人工音階)
  
  → ライヒの美学と矛盾
\`\`\`

**グラス作品における音階選択**：
\`\`\`
推奨順位:
  1. Dorian
     - グラスの「署名」旋法
     - 暗いが希望的
  
  2. Aeolian (Natural Minor)
     - オペラ作品に頻出
     - ドラマ性高い
  
  3. Phrygian
     - エキゾチック場面
     - 《Akhnaten》等
  
  4. Pentatonic
     - 初期作品
     - シンプルな場面
  
許容:
  - Major Scale (限定的)
  - Mixolydian (民族的場面)
  
避けるべき:
  - Chromatic
  - Lydian (明るすぎる)
  - Locrian (不安定すぎる)
\`\`\`

### 12.3 音域設定の原則

**楽器別推奨音域**：
\`\`\`
【ピアノ】
  低音域: A1~C3 (オスティナート用)
  中音域: C3~C5 (アルペジオ用)
  高音域: C5~C7 (旋律用)
  
  ライヒ作品:
    - 主に中音域 (C3~C5)
    - 1~1.5オクターブ範囲
    
  グラス作品:
    - より広い音域 (A2~C6)
    - 2~3オクターブ範囲

【マリンバ/ヴィブラフォン】
  実用音域: C3~C6
  最適音域: F3~F5 (明瞭性と音量)
  
  ライヒ作品:
    - 主にC4~C5 (中央オクターブ)
    - パターンは1オクターブ以内

【声楽】
  ソプラノ: C4~C6
  テノール: C3~C5
  
  最適範囲:
    - ソプラノ: E4~G5
    - テノール: G3~C5
  
  ライヒ作品:
    - 器楽的使用（母音のみ）
    - 中央音域重視
  
  グラス作品:
    - 言語的使用
    - より広い音域

【電子オルガン/シンセサイザー】
  実用音域: C2~C6 (MIDI標準)
  
  グラス作品:
    - 低音: C2~C3 (バス・ライン)
    - 中音: C3~C5 (アルペジオ)
    - 高音: C5~C6 (持続音)
\`\`\`

### 12.4 音高選択のアルゴリズム

\`\`\`python
class PitchSelector:
    def __init__(self, scale_type='pentatonic', root='C'):
        self.scale_type = scale_type
        self.root = root
        self.scales = self._init_scales()
    
    def _init_scales(self):
        """音階定義"""
        # MIDIノート番号 (C4 = 60)
        root_midi = self._note_to_midi(self.root + '4')
        
        intervals = {
            'pentatonic_major': [0, 2, 4, 7, 9],
            'pentatonic_minor': [0, 3, 5, 7, 10],
            'dorian': [0, 2, 3, 5, 7, 9, 10],
            'phrygian': [0, 1, 3, 5, 7, 8, 10],
            'aeolian': [0, 2, 3, 5, 7, 8, 10],
            'major': [0, 2, 4, 5, 7, 9, 11],
            'mixolydian': [0, 2, 4, 5, 7, 9, 10],
        }
        
        scale_intervals = intervals.get(self.scale_type, intervals['pentatonic_major'])
        
        # 3オクターブ生成 (C3~C6)
        scale_notes = []
        for octave in range(-1, 3):  # C3~C6
            for interval in scale_intervals:
                note = root_midi + (12 * octave) + interval
                if 48 <= note <= 84:  # C3~C6の範囲
                    scale_notes.append(note)
        
        return sorted(scale_notes)
    
    def _note_to_midi(self, note_name):
        """音名をMIDIノート番号に変換"""
        notes = {'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11}
        note = note_name[0]
        octave = int(note_name[-1])
        midi = notes[note] + (12 * octave)
        
        # シャープ/フラット処理
        if len(note_name) == 3:
            if note_name[1] == '#':
                midi += 1
            elif note_name[1] == 'b':
                midi -= 1
        
        return midi
    
    def generate_pattern(self, length=8, range_octaves=1.5, stepwise_ratio=0.7):
        """
        パターン生成
        
        Args:
            length: パターン長
            range_octaves: 音域（オクターブ）
            stepwise_ratio: 段階的進行の割合 (0~1)
        
        Returns:
            MIDIノート番号のリスト
        """
        import random
        
        pattern = []
        
        # 開始音（中央音域）
        start_note = self.scales[len(self.scales) // 2]
        pattern.append(start_note)
        
        # 音域制限
        min_note = int(start_note - (12 * range_octaves / 2))
        max_note = int(start_note + (12 * range_octaves / 2))
        available_notes = [n for n in self.scales if min_note <= n <= max_note]
        
        for i in range(1, length):
            last_note = pattern[-1]
            
            # 段階的進行 vs 跳躍
            if random.random() < stepwise_ratio:
                # 段階的進行（隣接音）
                current_index = available_notes.index(last_note)
                if random.random() < 0.5 and current_index > 0:
                    next_note = available_notes[current_index - 1]  # 下行
                elif current_index < len(available_notes) - 1:
                    next_note = available_notes[current_index + 1]  # 上行
                else:
                    next_note = last_note  # 同音反復
            else:
                # 跳躍（ランダム）
                next_note = random.choice(available_notes)
            
            pattern.append(next_note)
        
        return pattern
    
    def apply_symmetry(self, pattern, symmetry_type='mirror'):
        """
        対称性を適用
        
        Args:
            pattern: 元のパターン
            symmetry_type: 'mirror' (鏡映), 'retrograde' (逆行), 'inversion' (反行)
        
        Returns:
            対称性を適用したパターン
        """
        if symmetry_type == 'mirror':
            # 鏡映: 後半を前半の反転
            half = len(pattern) // 2
            return pattern[:half] + list(reversed(pattern[:half]))
        
        elif symmetry_type == 'retrograde':
            # 逆行: 完全に反転
            return list(reversed(pattern))
        
        elif symmetry_type == 'inversion':
            # 反行: 音程を上下反転
            first_note = pattern[0]
            inverted = [first_note]
            for i in range(1, len(pattern)):
                interval = pattern[i] - pattern[i-1]
                inverted.append(inverted[-1] - interval)  # 反転
            return inverted
        
        else:
            return pattern
\`\`\`

---

## 13. リズム構造の数学的記述

### 13.1 基本パルスとサブディビジョン

**パルス階層理論**：
\`\`\`
ミニマリズム音楽は明確なパルス階層を持つ

【レベル4: 小節】
  拍子: 4/4, 3/4, 5/8, 7/8等
  機能: 形式的区切り
  
【レベル3: 拍】
  4分音符 (通常)
  機能: リズムの基本単位
  
【レベル2: サブディビジョン】
  8分音符または16分音符
  機能: アルペジオ・パターンの基本
  
【レベル1: マイクロパルス】
  32分音符 (稀)
  機能: 装飾音、トリル

ライヒ作品:
  - 主に16分音符レベル
  - 32分音符は使用しない
  
グラス作品:
  - 8分音符~16分音符
  - より柔軟なリズム
\`\`\`

**テンポ設定の原則**：
\`\`\`
ライヒ作品:
  - 《Piano Phase》: ♩= 108 BPM
  - 《Clapping Music》: ♪= 158 BPM
  - 《Drumming》: ♩= 180~192 BPM
  - 《Music for 18 Musicians》: ♩.= 72 BPM
  
  範囲: ♩= 72~192 BPM
  特徴: テンポ不変（作品内で変化なし）

グラス作品:
  - 《Glassworks》: ♩= 96~132 BPM
  - 《Einstein》: ♩= 120~168 BPM
  - 《Satyagraha》: ♩= 132~144 BPM
  - 《Koyaanisqatsi》: ♩= 132~180 BPM
  
  範囲: ♩= 80~180 BPM
  特徴: 作品内でテンポ変化あり
\`\`\`

### 13.2 ポリリズムの数学的実装

**2対3ポリリズム**：
\`\`\`
定義: 2連音符と3連音符の同時進行

数学的記述:
  Layer A (2連): 周期 = 2 units
    時刻: 0, 2, 4, 6, 8, 10, 12, ...
  
  Layer B (3連): 周期 = 3 units
    時刻: 0, 3, 6, 9, 12, 15, 18, ...
  
  最小公倍数: LCM(2, 3) = 6
  再同期: 6 units後

視覚化 (6 units = 1サイクル):
  時刻: 0  1  2  3  4  5  6
  A:    X  -  X  -  X  -  X
  B:    Y  -  -  Y  -  -  Y

MIDI実装:
  - Time unit = 16分音符
  - Layer A: 8分音符 (2 units)
  - Layer B: 8分3連 (3 units per 拍)
  
  Tick resolution: 480 ticks/quarter note
  Layer A: note_on every 240 ticks
  Layer B: note_on every 160 ticks
\`\`\`

**3対4対5ポリリズム**：
\`\`\`
Layer A (3連): 周期 = 3
Layer B (4連): 周期 = 4
Layer C (5連): 周期 = 5

LCM(3, 4, 5) = 60
再同期: 60 units後

実装例 (グラス《Glassworks》"Island"):
  Base tempo: ♩= 84 BPM
  Time unit: 16分音符
  
  Layer A: 付点4分音符 (3 × 16分音符)
    Tick interval: 720 ticks
  
  Layer B: 8分音符 (2 × 16分音符)
    Tick interval: 240 ticks
  
  Layer C: 16分音符 (1 × 16分音符)
    Tick interval: 120 ticks
  
  再同期時間:
    60 × (60/84) × 0.25 = 10.7秒
\`\`\`

### 13.3 加算拍子の実装

**5/8拍子の実装**：
\`\`\`
グループ化パターン:

Pattern A: 3+2
  強拍配置: X x x X x
  リズム感: 「長-短」
  
  MIDI実装:
    Beat 1 (強): ticks 0
    Beat 2 (弱): ticks 120
    Beat 3 (弱): ticks 240
    Beat 4 (強): ticks 360
    Beat 5 (弱): ticks 480
    → 次小節: ticks 600

Pattern B: 2+3
  強拍配置: X x X x x
  リズム感: 「短-長」
  
  MIDI実装:
    Beat 1 (強): ticks 0
    Beat 2 (弱): ticks 120
    Beat 3 (強): ticks 240
    Beat 4 (弱): ticks 360
    Beat 5 (弱): ticks 480
\`\`\`

**7/8拍子の実装**：
\`\`\`
グループ化パターン:

Pattern A: 2+2+3
  強拍配置: X x X x X x x
  
  MIDI実装:
    Beat 1 (強): 0
    Beat 2 (弱): 120
    Beat 3 (中強): 240
    Beat 4 (弱): 360
    Beat 5 (中強): 480
    Beat 6 (弱): 600
    Beat 7 (弱): 720
    → 次小節: 840

Pattern B: 3+2+2
  強拍配置: X x x X x X x
  
Pattern C: 2+3+2
  強拍配置: X x X x x X x
\`\`\`

### 13.4 リズム生成アルゴリズム

\`\`\`python
class RhythmGenerator:
    def __init__(self, tempo=120, time_signature=(4, 4)):
        self.tempo = tempo
        self.time_signature = time_signature
        self.ticks_per_quarter = 480  # MIDI standard
    
    def generate_pulse_pattern(self, pattern_type='16th_notes', bars=4):
        """
        パルスパターン生成
        
        Args:
            pattern_type: '8th_notes', '16th_notes', 'triplets'
            bars: 小節数
        
        Returns:
            List of (onset_tick, duration_tick) tuples
        """
        numerator, denominator = self.time_signature
        ticks_per_bar = self.ticks_per_quarter * (4 / denominator) * numerator
        
        events = []
        
        if pattern_type == '8th_notes':
            subdivision = self.ticks_per_quarter // 2  # 8分音符
        elif pattern_type == '16th_notes':
            subdivision = self.ticks_per_quarter // 4  # 16分音符
        elif pattern_type == 'triplets':
            subdivision = self.ticks_per_quarter // 3  # 8分3連
        else:
            subdivision = self.ticks_per_quarter // 4
        
        current_tick = 0
        total_ticks = int(ticks_per_bar * bars)
        
        while current_tick < total_ticks:
            events.append((int(current_tick), subdivision))
            current_tick += subdivision
        
        return events
    
    def generate_additive_meter_pattern(self, grouping=[3, 2], bars=4):
        """
        加算拍子パターン生成
        
        Args:
            grouping: グループ化 (例: [3, 2] for 5/8)
            bars: 小節数
        
        Returns:
            List of (onset_tick, duration_tick, accent) tuples
        """
        total_beats = sum(grouping)
        ticks_per_beat = self.ticks_per_quarter // 2  # 8分音符基準
        ticks_per_bar = ticks_per_beat * total_beats
        
        events = []
        
        for bar in range(bars):
            bar_start = bar * ticks_per_bar
            beat_in_bar = 0
            
            for group_idx, group_size in enumerate(grouping):
                # 各グループの最初は強拍
                accent = 1.0 if group_idx == 0 else 0.7
                
                for beat_in_group in range(group_size):
                    onset = int(bar_start + (beat_in_bar * ticks_per_beat))
                    events.append((onset, ticks_per_beat, accent))
                    
                    beat_in_bar += 1
                    accent = 0.5  # グループ内の弱拍
        
        return events
    
    def generate_polyrhythm(self, ratios=[2, 3], duration_bars=4):
        """
        ポリリズム生成
        
        Args:
            ratios: リズム比率 (例: [2, 3] for 2:3)
            duration_bars: 持続時間（小節）
        
        Returns:
            Dict of layers with event lists
        """
        import math
        
        numerator, denominator = self.time_signature
        ticks_per_bar = self.ticks_per_quarter * (4 / denominator) * numerator
        total_ticks = int(ticks_per_bar * duration_bars)
        
        # 最小公倍数計算
        lcm = ratios[0]
        for ratio in ratios[1:]:
            lcm = abs(lcm * ratio) // math.gcd(lcm, ratio)
        
        layers = {}
        
        for layer_idx, ratio in enumerate(ratios):
            layer_events = []
            subdivision = total_ticks / (duration_bars * ratio)
            
            current_tick = 0
            while current_tick < total_ticks:
                layer_events.append((int(current_tick), int(subdivision)))
                current_tick += subdivision
            
            layers[f'layer_{ratio}'] = layer_events
        
        return layers
\`\`\`

---

## 14. 楽器編成と音色設計

### 14.1 ライヒ作品の典型的編成

**打楽器アンサンブル編成**：
\`\`\`
【《Drumming》型編成】
  Part I: チューニング・ボンゴ × 4ペア (8台)
  Part II: マリンバ × 3
  Part III: グロッケンシュピール × 3
  
  補助楽器:
    - 女声 × 2~3
    - ピッコロ × 1
    - 口笛 × 1 (奏者兼任)

【《Music for 18 Musicians》型編成】
  鍵盤打楽器:
    - ヴィブラフォン × 1
    - マリンバ × 3
    - シロフォン × 2
    - ピアノ × 4 (一部プリペアード)
  
  持続音楽器:
    - 女声 × 4
    - ヴァイオリン × 2
    - チェロ × 1
    - クラリネット × 2 (B♭ + バス)
  
  総数: 18~21名

【《Six Pianos》型編成】
  ピアノ × 6
  または
  ピアノ × 5 + マリンバ × 1
\`\`\`

**音色的特徴**：
\`\`\`
共通点:
  1. アコースティック楽器優先
  2. 明瞭な音の立ち上がり (percussive attack)
  3. 持続音と非持続音の組み合わせ
  4. 電子的増幅は最小限

禁止事項:
  - 電子シンセサイザー（初期作品）
  - エフェクト処理（リバーブ除く）
  - 非西洋楽器（一部例外）
\`\`\`

### 14.2 グラス作品の典型的編成

**電子アンサンブル編成**：
\`\`\`
【《Einstein on the Beach》型編成】
  鍵盤楽器:
    - 電子オルガン × 2
    - シンセサイザー × 1
  
  管楽器:
    - サクソフォン(ソプラノ) × 1
    - サクソフォン(アルト) × 1
    - フルート × 1
  
  声楽:
    - ソプラノ × 2~3
  
  弦楽器:
    - ヴァイオリン × 1 (ソロ)

【《Glassworks》型編成】
  鍵盤:
    - 電子オルガン × 2
    - シンセサイザー × 1~2
  
  管楽器:
    - サクソフォン(ソプラノ、アルト) × 2
    - フルート × 1
  
  総数: 5~6名

【オペラ編成 (《Satyagraha》等)】
  フル・オーケストラ:
    - 弦楽器: 12-10-8-6-4 (標準)
    - 木管: フルート × 2, オーボエ × 2, クラリネット × 2, ファゴット × 2
    - 金管: ホルン × 4, トランペット × 3, トロンボーン × 3
    - 打楽器: ティンパニ、その他
  
  合唱: 30~60名
  ソリスト: 5~10名
  
  総数: 80~120名
\`\`\`

**音色的特徴**：
\`\`\`
共通点:
  1. 電子楽器中心
  2. 全楽器を増幅
  3. 持続音重視
  4. リバーブ多用

音色パレット:
  - オルガン: Hammond B3またはFarfisa的
  - シンセ: アナログ的（Moog、ARP風）
  - サックス: ストレート・トーン（ヴィブラートなし）
  - 声楽: クラシック的発声
\`\`\`

### 14.3 MIDI音色設定

**General MIDI (GM) Program Numbers**：
\`\`\`
【ライヒ作品推奨音色】

ピアノ系:
  Program 1: Acoustic Grand Piano
    - 《Piano Phase》等
    - Velocity: 80~95
  
  Program 4: Electric Piano 1
    - やや明るい音
    - Velocity: 85~100

マリンバ/ヴィブラフォン:
  Program 12: Vibraphone
    - 《Music for 18 Musicians》
    - Velocity: 75~90
  
  Program 13: Marimba
    - 《Drumming》
    - Velocity: 80~95
  
  Program 14: Xylophone
    - 明るい音色
    - Velocity: 85~100

打楽器:
  Channel 10 (Percussion):
    Note 39: Hand Clap (《Clapping Music》)
    Note 54: Tambourine
    Note 60-62: Bongos

【グラス作品推奨音色】

オルガン系:
  Program 16: Drawbar Organ (Hammond B3風)
    - 《Einstein》《Glassworks》
    - Velocity: 85~100
    - Reverb: 30~40%
  
  Program 19: Rock Organ
    - より明るい、攻撃的
    - Velocity: 90~105

シンセサイザー:
  Program 81: Lead 1 (Square)
    - シンプルなリード音
    - Velocity: 80~95
  
  Program 88: New Age
    - 柔らかい持続音
    - Velocity: 70~85
  
  Program 90: Warm Pad
    - 背景和声用
    - Velocity: 60~75

管楽器:
  Program 64: Soprano Sax
    - 《Glassworks》
    - Velocity: 75~90
  
  Program 73: Flute
    - 澄んだ音色
    - Velocity: 70~85
  
  Program 71: Clarinet
    - 《Music for 18 Musicians》
    - Velocity: 75~90
\`\`\`

### 14.4 エフェクト設定

**リバーブ設定**：
\`\`\`
【ライヒ作品】
Room Size: Small~Medium
  - 《Piano Phase》: 15~20%
  - 《Drumming》: 10~15%
  - 《Music for 18 Musicians》: 20~25%

特徴:
  - 自然なアコースティック空間
  - 音の明瞭性を損なわない
  - プレート・リバーブ推奨

【グラス作品】
Room Size: Medium~Large
  - 《Einstein》: 30~40%
  - 《Glassworks》: 25~35%
  - 《Koyaanisqatsi》: 35~45%

特徴:
  - より広い空間感
  - 催眠的効果
  - ホール・リバーブ推奨
\`\`\`

**その他のエフェクト**：
\`\`\`
Chorus/Ensemble:
  - グラス作品で使用
  - Depth: 20~30%
  - Rate: 0.5~1.5 Hz
  - オルガン、シンセに適用

Delay:
  - 使用しない（両作曲家）
  - プロセスの明瞭性を損なう

Distortion/Overdrive:
  - 使用しない
  - クリーンな音色維持

EQ設定:
  - ライヒ: フラット~やや明るめ
    High: +2~3dB (8kHz)
  
  - グラス: 中域強調
    Mid: +3~4dB (1~2kHz)
    High: +2dB (8kHz)
\`\`\`

---

## 15. MIDI生成アルゴリズム

### 15.1 ライヒ・フェイジング実装

\`\`\`python
from midiutil import MIDIFile
import math

class ReichPhasingGenerator:
    def __init__(self, pattern, tempo=108, phase_shift_percent=1.5):
        """
        ライヒ式フェイジング生成器
        
        Args:
            pattern: MIDIノート番号のリスト
            tempo: BPM
            phase_shift_percent: 速度差（%）
        """
        self.pattern = pattern
        self.tempo = tempo
        self.phase_shift = phase_shift_percent / 100.0
        self.ticks_per_quarter = 480
    
    def generate_midi(self, output_file, duration_minutes=5):
        """MIDI生成"""
        midi = MIDIFile(2)  # 2トラック
        
        # トラック設定
        midi.addTempo(0, 0, self.tempo)
        midi.addTempo(1, 0, self.tempo)
        
        # パラメータ計算
        pattern_length = len(self.pattern)
        note_duration = 60.0 / self.tempo / 4  # 16分音符
        
        # 位相ずれ速度（音符/秒）
        notes_per_second = self.tempo / 60.0 * 4
        shift_speed = notes_per_second * self.phase_shift
        
        # 1音符分ずれる時間
        time_per_shift = 1.0 / shift_speed
        
        # 完全な位相サイクル時間
        cycle_time = pattern_length * time_per_shift
        
        print(f"1音符シフト時間: {time_per_shift:.2f}秒")
        print(f"完全サイクル時間: {cycle_time:.2f}秒")
        
        # トラック1: 固定速度
        current_time = 0
        end_time = duration_minutes * 60
        
        while current_time < end_time:
            for note in self.pattern:
                midi.addNote(0, 0, note, current_time, note_duration, 85)
                current_time += note_duration
        
        # トラック2: 位相ずれ
        current_time = 0
        phase_offset = 0.0  # 音符単位のオフセット
        
        while current_time < end_time:
            for i, note in enumerate(self.pattern):
                # 位相オフセットを考慮した音符選択
                shifted_index = int((i + phase_offset) % pattern_length)
                shifted_note = self.pattern[shifted_index]
                
                midi.addNote(1, 0, shifted_note, current_time, note_duration, 85)
                current_time += note_duration
            
            # 位相を進める
            cycle_duration = pattern_length * note_duration
            phase_offset += self.phase_shift * pattern_length
        
        # ファイル出力
        with open(output_file, 'wb') as f:
            midi.writeFile(f)
        
        return output_file

# 使用例：《Piano Phase》パターン
piano_phase_pattern = [64, 66, 71, 73, 74, 66, 64, 73, 71, 66, 74, 73]
generator = ReichPhasingGenerator(piano_phase_pattern, tempo=108)
generator.generate_midi("piano_phase.mid", duration_minutes=6)
\`\`\`

### 15.2 グラス加算プロセス実装

\`\`\`python
class GlassAdditiveGenerator:
    def __init__(self, tempo=120, time_signature=(4, 4)):
        self.tempo = tempo
        self.time_signature = time_signature
    
    def generate_base_pattern(self, length=5, scale_notes=None, stepwise_ratio=0.8):
        """
        基本パターン生成
        
        Args:
            length: パターン長
            scale_notes: 使用音階（MIDIノート番号リスト）
            stepwise_ratio: 段階的進行の割合
        
        Returns:
            MIDIノート番号のリスト
        """
        import random
        
        if scale_notes is None:
            # デフォルト: Dドリアン
            scale_notes = [62, 64, 65, 67, 69, 71, 72, 74, 76, 77]  # D3~F5
        
        pattern = []
        start_note = scale_notes[len(scale_notes) // 2]  # 中央音
        pattern.append(start_note)
        
        for _ in range(length - 1):
            last_note = pattern[-1]
            
            if random.random() < stepwise_ratio:
                # 段階的進行
                current_index = scale_notes.index(last_note)
                direction = random.choice([-1, 1])
                new_index = max(0, min(len(scale_notes) - 1, current_index + direction))
                pattern.append(scale_notes[new_index])
            else:
                # 跳躍
                pattern.append(random.choice(scale_notes))
        
        return pattern
    
    def apply_additive_process(self, base_pattern, num_stages=6, additions_per_stage=2):
        """
        加算的プロセス適用
        
        Args:
            base_pattern: 基本パターン
            num_stages: 段階数
            additions_per_stage: 各段階で追加する音符数
        
        Returns:
            段階ごとのパターンリスト
        """
        patterns = [base_pattern.copy()]
        
        scale_notes = sorted(list(set(base_pattern)))
        
        for stage in range(1, num_stages):
            new_pattern = patterns[-1].copy()
            
            for _ in range(additions_per_stage):
                # 追加位置をランダム決定
                insert_pos = len(new_pattern) // 2  # 中央付近
                
                # 追加音を選択（前後の音に近い音）
                if insert_pos > 0:
                    prev_note = new_pattern[insert_pos - 1]
                    # 段階的に近い音を選択
                    candidates = [n for n in scale_notes 
                                if abs(n - prev_note) <= 5]  # 完全4度以内
                    if candidates:
                        new_note = candidates[0]
                    else:
                        new_note = prev_note
                else:
                    new_note = scale_notes[0]
                
                new_pattern.insert(insert_pos, new_note)
            
            patterns.append(new_pattern)
        
        return patterns
    
    def generate_midi(self, patterns, output_file, repetitions_per_stage=12):
        """
        MIDI生成
        
        Args:
            patterns: パターンリスト
            output_file: 出力ファイル名
            repetitions_per_stage: 各段階の反復回数
        """
        midi = MIDIFile(1)
        midi.addTempo(0, 0, self.tempo)
        
        current_time = 0
        note_duration = 0.5  # 8分音符
        
        for pattern_idx, pattern in enumerate(patterns):
            print(f"Stage {pattern_idx}: Length {len(pattern)}, Pattern {pattern[:8]}...")
            
            for rep in range(repetitions_per_stage):
                for note in pattern:
                    midi.addNote(0, 0, note, current_time, note_duration, 90)
                    current_time += note_duration
        
        with open(output_file, 'wb') as f:
            midi.writeFile(f)
        
        return output_file

# 使用例
generator = GlassAdditiveGenerator(tempo=120)
base = generator.generate_base_pattern(length=5)
patterns = generator.apply_additive_process(base, num_stages=8)
generator.generate_midi(patterns, "glass_additive.mid")
\`\`\`

### 15.3 和声循環実装

\`\`\`python
class HarmonyEngine:
    def __init__(self):
        self.chord_library = {
            # Major chords
            'C': [60, 64, 67],
            'F': [65, 69, 72],
            'G': [67, 71, 74],
            'Bb': [58, 62, 65],
            
            # Minor chords
            'Am': [57, 60, 64],
            'Dm': [62, 65, 69],
            'Em': [64, 67, 71],
            'Gm': [67, 70, 74],
        }
    
    def generate_chord_progression(self, progression_type='4chord', num_cycles=8):
        """
        和声進行生成
        
        Args:
            progression_type: 進行タイプ
            num_cycles: サイクル数
        
        Returns:
            和音リスト
        """
        progressions = {
            '3chord': ['Dm', 'C', 'Bb'],
            '4chord': ['Dm', 'F', 'C', 'Bb'],
            '5chord': ['Am', 'G', 'F', 'G', 'Am'],
        }
        
        base_progression = progressions.get(progression_type, progressions['4chord'])
        
        chord_sequence = []
        for cycle in range(num_cycles):
            for chord_symbol in base_progression:
                chord_sequence.append({
                    'symbol': chord_symbol,
                    'notes': self.chord_library[chord_symbol],
                    'duration': 4,  # 4拍
                })
        
        return chord_sequence
    
    def generate_arpeggio(self, chord_notes, pattern='ascending'):
        """アルペジオパターン生成"""
        if pattern == 'ascending':
            return chord_notes + [chord_notes[-1] + 12]
        elif pattern == 'descending':
            return list(reversed(chord_notes)) + [chord_notes[0] - 12]
        elif pattern == 'alternating':
            return [chord_notes[0], chord_notes[2], 
                    chord_notes[1], chord_notes[2]] * 2
        return chord_notes

# 使用例
harmony = HarmonyEngine()
progression = harmony.generate_chord_progression('4chord', num_cycles=8)
for chord in progression[:4]:
    arp = harmony.generate_arpeggio(chord['notes'], 'ascending')
    print(f"{chord['symbol']}: {arp}")
\`\`\`

---

# 第V部：生成AI実装ガイド

## 16. 完全実装コードライブラリ

### 16.1 統合ライヒ生成システム

\`\`\`python
from midiutil import MIDIFile
import random
import math

class ReichCompositionGenerator:
    """ライヒ様式作品の完全生成システム"""
    
    def __init__(self, composition_type='phasing', duration_minutes=15):
        self.composition_type = composition_type
        self.duration_minutes = duration_minutes
        self.tempo = self._get_default_tempo()
        self.pattern = None
    
    def _get_default_tempo(self):
        """作品タイプ別デフォルトテンポ"""
        tempos = {
            'phasing': 108,
            'clapping': 158,
            'drumming': 180,
            'eighteen': 72,
        }
        return tempos.get(self.composition_type, 120)
    
    def generate_pattern(self, length=12, scale_type='pentatonic'):
        """基本パターン生成"""
        scales = {
            'pentatonic': [64, 66, 71, 73, 74],  # B Pentatonic
            'diatonic': [60, 62, 64, 65, 67, 69, 71],  # C Major
            'dorian': [62, 64, 65, 67, 69, 71, 72],  # D Dorian
        }
        
        scale = scales.get(scale_type, scales['pentatonic'])
        
        # ライヒ的特徴：高い対称性（70%以上）
        pattern = []
        half_length = length // 2
        
        # 前半生成
        for _ in range(half_length):
            pattern.append(random.choice(scale))
        
        # 後半は前半を部分的に鏡映
        for i in range(length - half_length):
            if random.random() < 0.7:  # 70%対称性
                mirror_index = half_length - 1 - i
                if mirror_index >= 0:
                    pattern.append(pattern[mirror_index])
                else:
                    pattern.append(random.choice(scale))
            else:
                pattern.append(random.choice(scale))
        
        self.pattern = pattern
        return pattern
    
    def generate_phasing_composition(self, output_file):
        """フェイジング作品生成"""
        if self.pattern is None:
            self.generate_pattern(length=12, scale_type='pentatonic')
        
        midi = MIDIFile(2)
        midi.addTempo(0, 0, self.tempo)
        midi.addTempo(1, 0, self.tempo)
        
        pattern_length = len(self.pattern)
        note_duration = 60.0 / self.tempo / 4  # 16分音符
        end_time = self.duration_minutes * 60
        
        # Voice 1: 固定
        time1 = 0
        while time1 < end_time:
            for note in self.pattern:
                midi.addNote(0, 0, note, time1, note_duration, 85)
                time1 += note_duration
        
        # Voice 2: 位相ずれ（1.5%速い）
        phase_shift = 0.015
        time2 = 0
        phase_offset = 0.0
        
        while time2 < end_time:
            for i, note in enumerate(self.pattern):
                shifted_idx = int((i + phase_offset) % pattern_length)
                midi.addNote(1, 0, self.pattern[shifted_idx], time2, note_duration, 85)
                time2 += note_duration
            
            phase_offset += phase_shift * pattern_length
        
        with open(output_file, 'wb') as f:
            midi.writeFile(f)
        
        print(f"✓ {output_file} 生成完了")
        print(f"  - パターン長: {pattern_length}")
        print(f"  - テンポ: {self.tempo} BPM")
        print(f"  - 演奏時間: {self.duration_minutes}分")
        
        return output_file
    
    def generate_additive_composition(self, output_file):
        """加算的プロセス作品生成"""
        if self.pattern is None:
            self.generate_pattern(length=13, scale_type='diatonic')
        
        midi = MIDIFile(3)  # 3トラック
        midi.addTempo(0, 0, self.tempo)
        
        # 基本パターンから段階的に音符を追加
        stages = self._create_additive_stages(self.pattern, num_stages=8)
        
        current_time = 0
        note_duration = 0.5  # 8分音符
        
        for stage_idx, stage_pattern in enumerate(stages):
            repetitions = 16 if stage_idx < 3 else 12
            
            for rep in range(repetitions):
                for note in stage_pattern:
                    # アルペジオ・トラック
                    midi.addNote(0, 0, note, current_time, note_duration, 90)
                    
                    # バス・トラック（5度下）
                    bass_note = note - 7
                    if bass_note >= 36:
                        midi.addNote(1, 0, bass_note, current_time, note_duration * 2, 75)
                    
                    # パルス・トラック（4拍ごと）
                    if rep % 4 == 0:
                        midi.addNote(2, 0, note + 12, current_time, 2.0, 80)
                    
                    current_time += note_duration
        
        with open(output_file, 'wb') as f:
            midi.writeFile(f)
        
        print(f"✓ {output_file} 生成完了")
        return output_file
    
    def _create_additive_stages(self, base_pattern, num_stages=8):
        """加算的段階生成"""
        stages = [base_pattern[:5]]  # 初期：5音のみ
        
        for stage in range(1, num_stages):
            prev = stages[-1]
            new_pattern = prev.copy()
            
            # 2音追加
            for _ in range(2):
                insert_pos = len(new_pattern) // 2
                if insert_pos < len(base_pattern):
                    new_pattern.insert(insert_pos, base_pattern[insert_pos])
            
            stages.append(new_pattern[:min(len(new_pattern), len(base_pattern))])
        
        return stages
\`\`\`

### 16.2 統合グラス生成システム

\`\`\`python
class GlassCompositionGenerator:
    """グラス様式作品の完全生成システム"""
    
    def __init__(self, duration_minutes=10, tempo=120):
        self.duration_minutes = duration_minutes
        self.tempo = tempo
        self.harmony_engine = HarmonyEngine()
        self.additive_engine = None
    
    def generate_complete_piece(self, output_file):
        """完全な作品生成"""
        midi = MIDIFile(3)  # 3トラック
        
        # テンポ設定
        midi.addTempo(0, 0, self.tempo)
        midi.addTempo(1, 0, self.tempo)
        midi.addTempo(2, 0, self.tempo)
        
        # セクション構造
        sections = self._plan_sections()
        
        current_time = 0
        
        for section in sections:
            if section['type'] == 'intro':
                current_time = self._generate_intro(midi, current_time, section['duration'])
            elif section['type'] == 'main':
                current_time = self._generate_main(midi, current_time, section['duration'])
            elif section['type'] == 'development':
                current_time = self._generate_development(midi, current_time, section['duration'])
            elif section['type'] == 'coda':
                current_time = self._generate_coda(midi, current_time, section['duration'])
        
        with open(output_file, 'wb') as f:
            midi.writeFile(f)
        
        print(f"✓ {output_file} 生成完了")
        print(f"  - 総演奏時間: {self.duration_minutes}分")
        print(f"  - テンポ: {self.tempo} BPM")
        print(f"  - セクション数: {len(sections)}")
        
        return output_file
    
    def _plan_sections(self):
        """セクション構造計画"""
        total_seconds = self.duration_minutes * 60
        
        return [
            {'type': 'intro', 'duration': total_seconds * 0.15},
            {'type': 'main', 'duration': total_seconds * 0.40},
            {'type': 'development', 'duration': total_seconds * 0.30},
            {'type': 'coda', 'duration': total_seconds * 0.15},
        ]
    
    def _generate_intro(self, midi, start_time, duration):
        """イントロ生成"""
        chord_sequence = self.harmony_engine.generate_chord_progression('3chord', num_cycles=2)
        
        current_time = start_time
        beat_duration = 60.0 / self.tempo
        
        for chord_obj in chord_sequence:
            chord_duration_beats = chord_obj['duration'] * 4
            arp_pattern = self.harmony_engine.generate_arpeggio(
                chord_obj['notes'], 'ascending'
            )
            
            time_in_chord = 0
            while time_in_chord < chord_duration_beats * beat_duration:
                for note in arp_pattern:
                    midi.addNote(0, 0, note, current_time, 0.5, 85)
                    current_time += 0.5
                    time_in_chord += 0.5 * beat_duration
                    
                    if time_in_chord >= chord_duration_beats * beat_duration:
                        break
        
        return current_time
    
    def _generate_main(self, midi, start_time, duration):
        """メインセクション生成（加算的プロセス）"""
        # 実装省略（前述のコード参照）
        return start_time + duration
    
    def _generate_development(self, midi, start_time, duration):
        """展開セクション生成"""
        # 実装省略
        return start_time + duration
    
    def _generate_coda(self, midi, start_time, duration):
        """コーダ生成"""
        # 実装省略
        return start_time + duration
\`\`\`

---

## 17. 検証基準とチェックリスト

### 17.1 ライヒ様式検証チェックリスト

\`\`\`
【音高・音階】
☑ ペンタトニックまたはダイアトニック音階
☑ 5~7音の音高集合
☑ 音域: 1~1.5オクターブ（初期）
☑ 半音進行は稀（装飾的使用のみ）

【リズム】
☑ 16分音符の連続パルス
☑ テンポ固定（作品内で不変）
☑ BPM: 72~192の範囲
☑ 拍子: 主に4/4または12/8

【プロセス】
☑ フェイジングまたは加算的プロセス
☑ 段階的変化（突然の転換なし）
☑ 各段階で12~24回反復
☑ 変化は知覚可能な速度

【構造】
☑ パターン長: 8, 12, 16拍（固定）
☑ 対称性: 70~90%
☑ 形式時間: 15~20分
☑ アーチ形式またはセクション形式

【楽器・音色】
☑ アコースティック楽器優先
☑ マリンバ、ヴィブラフォン、ピアノ
☑ 打楽器的アタック明瞭
☑ リバーブ: 10~25%

【禁止事項】
☐ 電子シンセサイザー（初期作品）
☐ 和声進行（静的和声のみ）
☐ テンポ変化
☐ 拍子変化
☐ 半音階的展開
\`\`\`

### 17.2 グラス様式検証チェックリスト

\`\`\`
【音高・音階】
☑ モーダル音階（Dorian, Phrygian等）
☑ 5~7音の基本集合
☑ 音域: 初期0.5~1オクターブ、発展で2~4オクターブ
☑ 分散和音的音型

【和声】
☑ 3~5和音の循環進行
☑ 機能和声の回避
☑ 共通音保持
☑ 調性的だが方向感覚喪失

【リズム】
☑ 加算拍子(5/8, 7/8, 11/8等)
☑ ポリリズム(2:3, 3:4等)
☑ 不変パルス(8分または16分音符)
☑ テンポ: 80~180 BPM

【プロセス】
☑ 加算的プロセス（音符の段階的追加）
☑ 各段階で8~24回反復
☑ パターン長: 可変(5~26音)
☑ 変化は段階的

【楽器・音色】
☑ 電子オルガン、シンセサイザー中心
☑ サクソフォン、フルート追加
☑ 全楽器を増幅
☑ リバーブ: 25~45%

【形式】
☑ 開いた形式または閉じた形式
☑ 5分~5時間（作品により変動）
☑ セクション単位の構成
☑ 和声サイクルによる統一

【禁止事項】
☐ ライヒ風フェイジング（位相ずれ）
☐ 完全な対称性
☐ 無調性・十二音技法
☐ 過度な半音階使用
\`\`\`

### 17.3 ライヒ vs グラス判定マトリクス

\`\`\`
あなたの作品の特徴をチェック:

【ライヒ的特徴】(各1点)
□ フェイジング・プロセスあり
□ パターン対称性 70%以上
□ パターン長固定
□ 単一調中心（転調なし）
□ 打楽器・鍵盤打楽器中心
□ テンポ完全固定
□ 形式時間 15~20分
□ アコースティック楽器のみ

【グラス的特徴】(各1点)
□ 加算的プロセス（音符追加）
□ パターン対称性 40%以下
□ パターン長可変
□ 和声進行あり（3~5和音）
□ 電子オルガン・シンセ使用
□ 拍子変化あり
□ 形式時間 可変
□ 電子楽器使用

【判定】
- ライヒ点数 ≥ 5点 → ライヒ様式
- グラス点数 ≥ 5点 → グラス様式
- 両方 ≥ 3点 → 混合様式（要再検討）
- 両方 < 3点 → ミニマリズムではない可能性
\`\`\`

---

## 18. トラブルシューティングガイド

### 18.1 よくある問題と解決策

**【問題1】生成された作品が「ミニマル」に聞こえない**

\`\`\`
症状:
  - 変化が多すぎる
  - パターンが不明瞭
  - 反復が少ない

診断:
  ✓ 反復回数を確認 → 各段階で最低12回以上反復すること
  ✓ パターン長を確認 → 8~16音に制限
  ✓ 変化速度を確認 → 1段階あたり1~2音の変化に留める

解決策:
  1. repetitions_per_stage パラメータを12以上に設定
  2. pattern_length を12以下に制限
  3. additions_per_stage を2以下に設定
  
  修正例:
    # 修正前
    patterns = apply_additive_process(base, num_stages=10, additions_per_stage=4)
    
    # 修正後
    patterns = apply_additive_process(base, num_stages=6, additions_per_stage=2)
\`\`\`

**【問題2】フェイジングが機能しない**

\`\`\`
症状:
  - 2つの声部が同期したまま
  - 位相ずれが知覚できない
  
診断:
  ✓ phase_shift_percent を確認 → 1.0~3.0の範囲か
  ✓ テンポを確認 → 遅すぎる/速すぎないか
  ✓ 演奏時間を確認 → 最低5分以上必要

解決策:
  1. phase_shift_percent = 1.5 (推奨値)
  2. tempo = 108 BPM (《Piano Phase》標準)
  3. duration_minutes = 6以上
  
  検証コード:
    # 位相サイクル時間を計算
    pattern_length = 12
    notes_per_second = tempo / 60 * 4  # 16分音符
    shift_speed = notes_per_second * (phase_shift / 100)
    cycle_time = pattern_length / shift_speed
    
    print(f"完全サイクル時間: {cycle_time:.1f}秒")
    # 目安: 60~120秒が理想的
\`\`\`

**【問題3】和声循環が単調**

\`\`\`
症状:
  - 和音変化が退屈
  - グラス的な「流動感」がない

診断:
  ✓ 和音数を確認 → 3~5和音が適切
  ✓ 共通音保持を確認 → 和音間で1~2音共通か
  ✓ サイクル長を確認 → 4~8小節が適切

解決策:
  1. 和声進行を4和音サイクルに
  2. 共通音保持を実装
  
  実装例:
    # 共通音保持チェック
    def has_common_tones(chord1, chord2, min_common=1):
        common = set(chord1) & set(chord2)
        return len(common) >= min_common
    
    # 進行生成時に検証
    for i in range(len(progression) - 1):
        if not has_common_tones(progression[i], progression[i+1]):
            print(f"警告: 和音{i}→{i+1}に共通音なし")
\`\`\`

**【問題4】リズムが不規則・複雑すぎる**

\`\`\`
症状:
  - ポリリズムが聞き取れない
  - 拍子感が失われる

診断:
  ✓ ポリリズム比率を確認 → 2:3, 3:4が限界
  ✓ 基準パルスを確認 → 8分または16分音符が明確か
  ✓ 拍子変化頻度を確認 → 変化しすぎていないか

解決策:
  1. ポリリズムは2層まで
  2. 基準パルスを1トラックで常に演奏
  3. 拍子変化は最小限（2~3種類まで）
  
  推奨実装:
    # 基準パルストラック追加
    def add_pulse_track(midi, track, duration):
        current_time = 0
        pulse_interval = 0.5  # 8分音符
        
        while current_time < duration:
            midi.addNote(track, 0, 60, current_time, pulse_interval, 70)
            current_time += pulse_interval
\`\`\`

**【問題5】MIDI出力が期待と異なる**

\`\`\`
症状:
  - 音が鳴らない
  - タイミングがずれる
  - 音色が期待と違う

診断:
  ✓ MIDIノート番号を確認 → 0~127の範囲か
  ✓ ベロシティを確認 → 0は無音、1~127が有効
  ✓ トラック番号を確認 → 0から始まるか
  ✓ チャンネル番号を確認 → 0~15が有効

解決策:
  1. ノート番号検証:
     \`\`\`python
     if not (0 <= note <= 127):
         raise ValueError(f"Invalid MIDI note: {note}")
     \`\`\`
  
  2. ベロシティ設定:
     \`\`\`python
     velocity = max(1, min(127, velocity))  # 1~127に制限
     \`\`\`
  
  3. 音色設定:
     \`\`\`python
     midi.addProgramChange(track, channel, time, program)
     # program: 0~127 (General MIDI)
     \`\`\`
\`\`\`

### 18.2 品質チェック自動化

\`\`\`python
class MinimalismQualityChecker:
    """ミニマリズム作品の品質自動検証"""
    
    def __init__(self, midi_file):
        self.midi_file = midi_file
        self.issues = []
    
    def check_all(self):
        """全チェック実行"""
        self.check_repetition()
        self.check_pattern_length()
        self.check_tempo_stability()
        self.check_pitch_range()
        
        return self.generate_report()
    
    def check_repetition(self):
        """反復回数チェック"""
        # 実装：パターンの反復を検出
        repetition_count = self._count_repetitions()
        
        if repetition_count < 8:
            self.issues.append({
                'severity': 'ERROR',
                'message': f'反復回数不足: {repetition_count}回 (最低8回必要)'
            })
        elif repetition_count < 12:
            self.issues.append({
                'severity': 'WARNING',
                'message': f'反復回数少ない: {repetition_count}回 (推奨12回以上)'
            })
    
    def check_pattern_length(self):
        """パターン長チェック"""
        pattern_length = self._detect_pattern_length()
        
        if pattern_length > 16:
            self.issues.append({
                'severity': 'WARNING',
                'message': f'パターン長が長い: {pattern_length}音 (推奨8~16音)'
            })
    
    def check_tempo_stability(self):
        """テンポ安定性チェック"""
        tempo_changes = self._count_tempo_changes()
        
        if tempo_changes > 0:
            self.issues.append({
                'severity': 'ERROR',
                'message': f'テンポ変化あり: {tempo_changes}回 (ライヒ様式では不可)'
            })
    
    def check_pitch_range(self):
        """音域チェック"""
        pitch_range = self._calculate_pitch_range()
        
        if pitch_range > 24:  # 2オクターブ以上
            self.issues.append({
                'severity': 'WARNING',
                'message': f'音域広すぎ: {pitch_range}半音 (推奨12~18半音)'
            })
    
    def generate_report(self):
        """レポート生成"""
        report = "=== ミニマリズム品質チェック ===\n\n"
        
        if not self.issues:
            report += "✓ 問題なし！ミニマリズム様式に適合しています。\n"
        else:
            errors = [i for i in self.issues if i['severity'] == 'ERROR']
            warnings = [i for i in self.issues if i['severity'] == 'WARNING']
            
            if errors:
                report += f"✗ エラー {len(errors)}件:\n"
                for e in errors:
                    report += f"  - {e['message']}\n"
            
            if warnings:
                report += f"\n⚠ 警告 {len(warnings)}件:\n"
                for w in warnings:
                    report += f"  - {w['message']}\n"
        
        return report
\`\`\`

---

## 【最終まとめ】生成AI実装のための完全仕様

### ライヒ様式の最小実装

\`\`\`python
# 最小限のライヒ様式作品生成
pattern = [64, 66, 71, 73, 74, 66, 64, 73, 71, 66, 74, 73]  # Piano Phase
generator = ReichPhasingGenerator(pattern, tempo=108, phase_shift_percent=1.5)
generator.generate_midi("my_reich_piece.mid", duration_minutes=6)
\`\`\`

### グラス様式の最小実装

\`\`\`python
# 最小限のグラス様式作品生成
generator = GlassCompositionGenerator(duration_minutes=5, tempo=120)
generator.generate_complete_piece("my_glass_piece.mid")
\`\`\`

### 実装の10原則

\`\`\`
1. 反復を恐れるな → 12~24回は当然
2. 変化は微小に → 1段階1~2音まで
3. テンポを守れ → 変化させない（ライヒ）
4. 音域を制限せよ → 1~1.5オクターブから開始
5. 対称性を意識せよ → ライヒは70%以上
6. 和声を循環させよ → グラスは3~5和音
7. パルスを明確に → 16分音符が基準
8. アルペジオを活用せよ → 和音の分散
9. 音色はシンプルに → 過度なエフェクト不要
10. 検証を怠るな → チェックリスト必須
\`\`\`

この仕様書により、ライヒとグラスのミニマリズム音楽の本質を完全に理解し、生成AIで再現可能な作品を作ることができます。
`
